# 瓊林擷芳：中文輸入法常用概念術語 <!-- omit in toc -->

〔朱宇浩於乙巳年閏六月十一日〕

自當代中文輸入法肇基以來，四十餘年間，其相關概念曾隨時間和技術的發展而變化，亦不斷融合傳統文化、統計學、現代計算機科學等專業術語。部分名詞的定義會偏離其在原學科中的嚴格定義；部分概念會有多種不同的定義方式；同一名詞在不同的語境下或有不同指代。這些都可能會造成學習和交流上的困難。

爲了更好地理解輸入法的工作原理和相關概念，方便不同輸入法之間的交流和學習，本文採用輸入法文献和同好圈中比較通行、常用、一致的屬於和定義，將其作爲行業最佳實踐，並在必要時附上例子、辨析和總結。祈可促進輸入法相關概念的學習、理解和交流。

## 1. 方案類型

### 1.1. 音碼

「字音輸入法」，又稱「拼音輸入法」「音碼輸入法」「拼音」「音碼」等，是指通過輸入漢字的讀音來確定候選字範圍的輸入法。這類輸入法通常基於某類拼音系统，如漢語拼音、注音、方言拼音、音標等。

純粹的音碼（**純音**），不依賴除讀音外的其他信息來確定候選字的範圍。也就是説，當出現一個新漢字時，只要知道它的讀音，就可以確定它的完整編碼。

::: tip 方案舉例

全拼輸入法，雙拼輸入法、注音輸入法，方言拼音輸入法。

:::

### 1.2. 形碼

字形輸入法，又稱「形碼輸入法」「形碼」等，是指通過輸入漢字的字形特徵來確定候選範圍的輸入法。這類輸入法通常基於漢字的某類形態特徵，如部首、筆劃、結構等。

純粹的形碼（**純形**），不依賴除字形外的其他信息來確定候選字的範圍。也就是説，當出現一個新漢字時，只要知道它字形特徵，就可以確定它的完整編碼。

::: tip 方案舉例

筆劃輸入法（筆劃）、四角號碼輸入法（特徵）、五筆字形輸入法（部首、結構）、倉頡輸入法（部首、特徵）。

:::

### 1.3. 音形碼

音形輸入法，又稱「音形碼」，是指通過同時輸入漢字的讀音和字形特徵來確定候選字範圍的輸入法。讀音對應的編碼在前，字形對應的編碼在後。

音形輸入法以音爲主，以形爲輔，部分情況下字形的部分只作為補充信息而被省略。

當出現一個新漢字時，只知道漢字的讀音或字形特徵，無法保證能夠確定它的完整編碼。

::: tip 方案舉例

自然碼輔助碼、小鶴雙形、聲筆。

:::

### 1.4. 形音碼

形音輸入法，又稱「形音碼」，是指通過同時輸入漢字的字形特徵和讀音來確定候選字範圍的輸入法。字形對應的編碼在前，讀音對應的編碼在後。

音形輸入法以形爲主，以音爲輔，部分情況下字音的部分只作為補充信息而被省略。

當出現一個新漢字時，只知道漢字的讀音或字形特徵，無法保證能夠確定它的完整編碼。

::: tip 方案舉例

米十五筆、字源輸入法。

:::

### 1.5. 混合碼

混合編碼輸入法，是指一個漢字會使用兩種或以上的編碼方式。比如一個漢字既可以通過純音方式輸入，也可以通過純形方式輸入，也可以通過音形方式輸入，也可以通過音形方式輸入。

大部分的音形輸入法或形音輸入法都屬於混合輸入法。它們會提供兩種及以上的編碼方式，并在部分情況下回退化爲純音或純形輸入法。

::: tip 方案舉例

兩分輸入法（大字集形碼遞歸）

:::

### 1.6. 無理碼

無理碼輸入法，是指輸入的編碼無法直接對應到漢字的讀音或字形特徵。每個漢字的編碼都需要特殊記憶。

::: tip 方案舉例

電報碼，Unicode萬國碼。

:::

## 2. 編碼屬性

本節中，「漢字」可以是單個漢字，也可以是詞語或短語，也可以是任何其他的字符。

### 2.1. 編碼

編碼，指的是一串字符序列，包括字母、數字、符號等。它們會對應到一個或多個漢字。

#### 2.1.1. 編碼字符集合

編碼字符集合，又稱編碼字符空間，指的是某一個輸入法所使用的所有編碼字符的集合。

::: tip 舉例

五筆字形的編碼集合為 a 到 y 的所有 25 个字母。

:::

#### 2.1.2. 編碼空間

編碼空間，指的是一個輸入法中所有合法的編碼的集合。

::: tip 舉例

全拼輸入法的編碼空間包括所有合法的拼音，如 `pian`、`xian`、`hao` 等。`pian` 是合法的編碼，而 `pianx` 則不是合法的編碼。因此全拼的編碼空間不包括 `pianx`。

:::

#### 2.1.3. 編碼分割

編碼分割，又稱編碼分離，是指輸入法在輸入時，將連續的編碼字符串分割若干合法的編碼（這些編碼需在編碼空間中）。

#### 2.1.4. 分割符

分割符，指的是用於分割編碼的字符，它們往往不屬於某輸入方案的編碼集合。使用分割符可以幫助輸入法將連續的編碼無歧義地分割成若干部分。

#### 2.1.5. 理論編碼和實際編碼

理論編碼，指的是輸入法在設計時所定義的編碼方式。

實際編碼，指的是用戶在使用輸入法時實際輸入的編碼。有時候，爲了消除歧義，實際編碼會與理論編碼有所不同，比如使用額外的分隔符。

::: tip 舉例

「西安」在全拼輸入法中的的理論編碼為 `xian`，實際編碼可能是 `xian`（不進行手工分割），也可能是 `xi'an`（使用了單引號作爲分隔符）。

:::

### 2.2. 「分割唯一」屬性

分割唯一，是指輸入法在輸入時，可以將連續的編碼分割爲一種且唯一的方式，而不出現歧義。

::: tip 舉例

假定空格鍵是分割符號，則輸入連續編碼 `ni hao shi jie` 時，編碼會被分割爲 `ni ` `hao ` `shi ` `jie ` 四個部分，並且分割方式是唯一的。

:::

### 2.3. 「分割不唯一」屬性

分割不唯一，是指輸入法在輸入時，連續編碼可以被分割爲多種合法的編碼組合，從而有可能產生歧義。具體的分割方法有可能會依賴於上下文或其他信息（聯想）。

::: tip 舉例

連續編碼 `nihaoshijie` 時，編碼可能會被分割爲 `ni  hao  shi  jie` 四個部分，也可能被分割為  `ni  hao  shi  ji  e` 五個部分。兩種分割方法都是合法的。

:::

### 2.4. 「前綴碼」屬性

前綴碼，又稱前置碼，自由前綴碼。是指任何一個漢字的編碼都不是任何其他漢字編碼的前若干碼。

前綴碼的編碼分割是內向性的，也就是説當前編碼自身可以確定它的結束，而不需要看到下一个有效編碼。

::: tip 舉例

一個前綴碼方案中，日的編碼爲ri，則不存在任意一個編碼，其前兩碼是ri。

一個方案中所有的編碼都是以空格鍵結尾的，且空格鍵只作為結尾，則它具有前綴碼屬性。

:::

::: tip 方案舉例

宇浩日月（同是爲前綴碼和定長碼）。

:::

::: warning 相關屬性

前綴碼具有分割唯一屬性。

**任何**定長碼或變長碼，如果在其編碼后附加額外的分隔符號（如空格），則其編碼具有前綴碼屬性。

:::

### 2.5. 「頂功」屬性

頂功，是指一類可以通過匹配編碼字符集合的**組合模式**而達到**唯一編碼分割**的編碼方式。

頂功碼的編碼分割是外向性的，也就是説需要看到下一个有效編碼才能確定當前編碼的結束。

::: tip 舉例

舉例一：某方案中，一個漢字的第一個編碼，被設計為左手的按鍵，而剩余的編碼被設計在右手上。這樣的編碼是否具有頂功屬性？

這樣的編碼方式具有頂功屬性。因為每當看到左手的按鍵時，就可以這是一個新漢字的開始碼。

舉例二：某方案中，一個漢字的前兩碼都是輔音字母，而剩余的編碼是元音字母 `aeiou`。這樣的編碼是否具有頂功屬性？

這樣的編碼方式具有頂功屬性。因為每當看到兩個輔音字母時，就可以確定這是一個新漢字的開始碼。否則，它永遠都是前一個漢字的後續碼。

舉例三：某方案中，一個漢字的編碼要麼是兩個的字母，要麼是三到四個字母加上一個空格鍵。這樣的編碼是否具有頂功屬性？

這樣的編碼方式具有頂功屬性。如果出現了連續四個字母，則觀察第五碼，如果它是空格鍵，則這是一個五碼字的結束（四個字母加一個空格鍵）。如果第五碼不是空格鍵，則其前兩碼構成一個兩碼字。

這種情況，我們需要往前看三碼方能判斷編碼的分割情況。這個方案稱為「五二頂」，也就是觀察第五碼來判斷前兩碼是否可以唯一分割并上屏。

:::

::: warning 相關屬性

頂功碼具有分割唯一屬性。

**任何**定長碼或變長碼，如果在其編碼后附加額外的分隔符號（如空格），則其編碼具有前綴碼屬性。

:::

關於更多頂功方面的相關信息，請移步《[顶功 · 集萃](https://ding.tansongchen.com/)》。

### 2.6. 「定長」屬性

定長，指的是每個漢字的編碼**最大**長度固定。也就是説，無論輸入什麼漢字，編碼的最大長度都是一樣的。當出現一個新的漢字時，它的最大長度是確定的。

::: tip 方案舉例

五筆字形（最短編碼長度為3，最長編碼長度爲4）、倉頡（最短編碼長度爲1，最長編碼長度爲5）。

:::

::: warning 相關屬性

定長碼不一定具有「分割唯一」的屬性。

定長碼通過添加分隔符號（如空格），可以在實際編碼中達到「分割唯一」的屬性。

:::

### 2.7. 「絕對定長」屬性

絕對定長，是指編碼的長度在所有情況下都是固定的。也就是説，無論輸入什麼漢字，編碼的長度都是一樣的。

::: tip 方案舉例

雙拼輸入法。

:::

::: warning 相關屬性

絕對定長碼具有「分割唯一」的屬性。

:::

### 2.8. 「可變長」屬性

可變長碼，又稱變長碼、不定長碼，指的是編碼長度不固定的輸入法。也就是説，輸入不同的漢字，編碼的最大長度可能會有所不同。當出現一個新的漢字時，它的最大長度是不確定的。

::: tip 方案舉例

筆劃輸入法、山人全息碼。

:::

::: warning 相關屬性

變長碼不一定具有「分割唯一」的屬性。

變長碼通過添加分隔符號（如空格），可以在實際編碼中達到「分割唯一」的屬性。

:::

## 3. 上屏方式

### 3.1. 整句上屏

整句上屏，是指輸入法在用戶輸入多個漢字後，將這些漢字一起上屏。

隨著信息技術的不斷發展，整句上屏往往配合輸入聯想功能，通過隱馬爾可夫鏈、LLM等技術，實現對整句的預測。

### 3.2. 唯一上屏

唯一上屏，指的是當前輸入的編碼可以唯一確定為一個漢字（後選項為一）時，直接上屏該漢字。

唯一上屏的觸發條件一定是內生的。也就是説，它不依賴下一個漢字的編碼來確定當前漢字編碼的結束。它包括：

1. 當前編碼的長度達到最大長度；
1. 前綴碼最後一碼的編碼字符出現。
1. 雖然存在後續編碼空間，但已无其他漢字在預測區。

::: tip 舉例

一個輸入法的編碼最大碼長為4，當用戶輸入的編碼為`abcd`，且這個編碼對應了唯一字符（如`漢`），則直接上屏`漢`。

:::

::: tip 方案舉例

三碼鄭碼（六碼除重模式）。該模式下，編碼為不定長狀態。當用戶輸入的單字編碼構成唯一的漢字候選項且无後續預測（未成詞），則直接上屏；當用戶輸入的單字編碼參與了後續預測（成詞），則不直接上屏，而是等待用戶輸入更多的編碼字符判斷是否上屏詞語或是單字。

:::

### 3.3. 空格上屏

空格上屏，是指在編碼後添加空格鍵，表示當前編碼已經完成，并將首選項上屏。

空格鍵本身不上屏任何符號，而是將一個方案的實際編碼轉換為**前綴碼**。因此，空格上屏可以視爲一種特殊的「唯一確定上屏」。

### 3.4. 選重上屏

選重上屏，是指在用戶輸入編碼後，通過選擇候選字來確定上屏的漢字。

選充鍵本身不上屏任何符號，而是將一個方案的實際編碼轉換為**前綴碼**。因此，選重上屏可以視爲一種特殊的「唯一確定上屏」。但這種所謂「唯一確定」是在實際輸入過程當中及時更新的，不具備通用的預見性。

### 3.5. 延遲上屏

延遲上屏，是指在用戶輸入編碼且達到唯一分割條件是，不立即上屏，而是等待用戶繼續輸入更多的編碼字符後再上屏。

延遲上屏時，候選項可能唯一，也可能不唯一。

延遲上屏的觸發條件一定是內生的。也就是説，它不依賴下一個漢字的編碼來確定當前漢字編碼的結束。它包括：

1. 當前編碼的長度達到最大長度；
1. 前綴碼最後一碼的編碼字符出現。

延遲上屏可以防止用戶輸入全碼後自動上屏，從而避免輸入錯誤無法回改的情況。

::: tip 方案舉例

RIME 輸入法將 `auto_select` 設置爲 `false`，則在輸入編碼後不會立即上屏，而是等待用戶繼續輸入一個字符後上屏前字。

:::

### 3.6. 頂功上屏

頂功上屏，是指在用戶輸入編碼時，前若干碼可以確定為唯一分割，則直接上屏其對應的候選漢字，並且保留剩餘編碼在輸入區。

頂功上屏時，唯一確定的編碼分割所對應的漢字可以是唯一候選，也可以是多個候選。但一般頂出首選。

頂功上屏的觸發條件一定是外生的。也就是説，它必須依賴下一個（或幾個）漢字的編碼來確定當前漢字編碼的結束。它包括：

1. 當前編碼的字符集合的組合模式達到了唯一編碼分割，可以確定一個漢字編碼的結束；
1. 當輸入某一編碼時，本編碼的所有後綴都不在合法的編碼空間中，則立刻上屏前續編碼對應的首選（包括預測項），且保留最後一碼。

### 3.7. 符號上屏

符號上屏，是指在輸入編碼後輸入標點符號，將當前第一候選字和符號同時上屏。

符號鍵本身不僅上屏前字，同時也上屏了符號本身。因此它可以根據具體情況視為以下上屏方式的一種特例：

1. 如果前續編碼已經形成唯一分割，則符號上屏可以視爲「延遲上屏」的一種。
1. 如果前續編碼未形成唯一分割，則符號上屏可以視爲「頂功上屏」的一種。此時，符號鍵會將實際編碼轉換為具有頂功屬性的編碼，實現了頂功輸出。

## 4. 編碼衝突

### 4.1. 重碼

重碼，又稱編碼衝突，是指兩個或多個漢字的編碼相同。

### 4.2. 選重

選重，是指在輸入法中，當用戶輸入的編碼對應多個候選漢字時，通過選擇候選漢字來確定上屏的漢字。選重方法包括數字選擇、符號選擇、鼠標選擇等。

### 4.3. 靜態重碼數

靜態重碼數，又稱「絕對重碼數」「靜重」，指的是在一個字符集中，**編碼完全相同的漢字的數量**。它不包含關於字頻的信息，因此，靜態重碼只關注編碼的唯一性。

注意，靜態重碼必須依賴於某一字集，字集的不同會導致靜態重碼數的不同。

::: details 靜態重碼數的計算公式和代碼

假設 $Z$ 為一個漢字的集合，$M$ 為一個編碼的集合。漢字 $z_{ij}$ 定義為編碼為 $m_i$ 的第 $j$ 個漢字，順序隨機。那麽，靜態重碼數可以表達為：

$$N_{s} = \mid \{z_{ia}, z_{ib}  \text{ if } M(z_{ia}) = M(z_{ib}) \text{ for all } a,b \in J_i \text{ and } i \in I \}.$$

以下為 Python 代碼示例，使用 numpy 包計算靜態重碼數：

```python
import numpy as np
import typing
import numpy.typing as npt

def get_static_dup_rate(
    char: npt.NDArray[np.dtype("<U1")],
    code: npt.NDArray[np.dtype("<U4")],
    charset: typing.Sequence,
) -> int:
    """计算某个字集内的静态重码数

    Args:
        char (npt.NDArray[np.dtype): 元素为汉字。
        code (npt.NDArray[np.dtype): 元素为编码。
        charset (typing.Sequence): 字集。元素为汉字。比如通规汉字或 GBK.

    Returns:
        int: 静态重码数：
    """
    idx_char_in_scope = np.isin(char, charset)
    _, dup_counts = np.unique(code[idx_char_in_scope], return_counts=True)
    return dup_counts[dup_counts > 1].sum()
```

:::

### 4.4. 靜態重碼組數

靜態重碼組數，指的是在一個字符集中，**編碼完全相同的漢字組數**。

由於部分編碼可能對應超過兩個漢字，因此以下不等式成立：

$$
靜態重碼數 \ge 靜態重碼組數 \times 2
$$

### 4.5. 靜態選重數

靜態選重數，指的是在一個字符集中，**編碼完全相同、且不為首選的漢字數量**。以下等式成立：

$$
靜態選重數 = 靜態重碼數 - 靜態重碼組數
$$

### 4.6. 靜態選重率

靜態選重率，是指在一個字符集中，**編碼完全相同、且不為首選的漢字數量**與**字集包含字數**之比。它可以表達為：

$$
靜態選重率 = \frac{靜態選重數}{字集包含漢字數量}
$$

### 4.7. 動態重碼率

動態重碼率，又稱「動重」「字頻加權選重率」，是指編碼完全相同、且不為首選的漢字的出現頻率。它可以表達為：

$$

動態重碼率 = \sum_i (需要選重的漢字_i \times 漢字出現頻率_i)

$$

::: details 動態重碼率的計算公式和代碼

假設 $Z$ 為一個漢字的集合，$M$ 為一個編碼的集合，$p:Z\rightarrow [0,1]$ 為漢字到其出現頻率的映射。用編碼和字頻對漢字排序，使漢字 $z_{ij}$ 是編碼為 $m_i$ 的第 $j$ 個漢字，$i \in I$, $j \in J_i$, 且滿足 $a\geq b$ 時，$f(z_{ia})\geq f(z_{ib})$。
動態選重率可以表達為：

$$N_{d} = \sum\limits_{i \in I, j \in J_i/\{1\}} p(z_{ij}).$$

```python
def get_dynamic_dup_rate(
    code: npt.NDArray[np.dtype("<U4")],
    freq: npt.NDArray,
    idx_sorted_freq: npt.NDArray[np.dtype("i")],
) -> float:
    """计算字频加权选重率（动态重码率）

    Args:
        code (npt.NDArray[np.dtype): 元素为汉字对应的编码。
            宇浩输入法编码不超过四位，所以编码的格式是 4 个 Unicode 组成的字符串。
        freq (npt.NDArray): 元素为汉字对应的字频。
        idx_sorted_freq (npt.NDArray[np.dtype): 根据字频进行降序排列的索引。
            一般的：idx_sorted_freq = np.argsort(-freq)
            因为这一项操作只需要进行一次，故而不需要放入函数中循环。
    Returns:
        float: 字频加权选重率。
    """
    # 字频降序后的编码和字频列表
    code = code[idx_sorted_freq]
    freq = freq[idx_sorted_freq]
    # 得到第一个非重复的编码的索引
    _, idx_unique_freq = np.unique(code, return_index=True)
    # 生成一个掩码层，将重复的编码筛出
    duplicated_mask = np.full(freq.shape, True)
    duplicated_mask[idx_unique_freq] = False
    # 重复的编码，就是需要选重的字
    # 将这些重复的编码所对应的字频进行求和
    return freq[duplicated_mask].sum()
```

:::
