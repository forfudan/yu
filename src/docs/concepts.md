# 琼林撷芳：中文输入法常用概念术语 <!-- omit in toc -->

〔朱宇浩于乙巳年闰六月十一日〕

自当代中文输入法肇基以来，四十余年间，其相关概念曾随时间和技术的发展而变化，亦不断融合传统文化、统计学、现代计算机科学等专业术语。部分名词的定义会偏离其在原学科中的严格定义；部分概念会有多种不同的定义方式；同一名词在不同的语境下或有不同指代。这些都可能会造成学习和交流上的困难。

为了更好地理解输入法的工作原理和相关概念，方便不同输入法之间的交流和学习，本文采用输入法文献和同好圈中比较通行、常用、一致的属于和定义，将其作为行业最佳实践，并在必要时附上例子、辨析和总结。祈可促进输入法相关概念的学习、理解和交流。

## 1. 方案类型

### 1.1. 音码

「字音输入法」，又称「拼音输入法」「音码输入法」「拼音」「音码」等，是指通过输入汉字的读音来确定候选字范围的输入法。这类输入法通常基于某类拼音系统，如汉语拼音、注音、方言拼音、音标等。

纯粹的音码（**纯音**），不依赖除读音外的其他信息来确定候选字的范围。也就是说，当出现一个新汉字时，只要知道它的读音，就可以确定它的完整编码。

::: tip 方案举例

全拼输入法，双拼输入法、注音输入法，方言拼音输入法。

:::

### 1.2. 形码

字形输入法，又称「形码输入法」「形码」等，是指通过输入汉字的字形特征来确定候选范围的输入法。这类输入法通常基于汉字的某类形态特征，如部首、笔划、结构等。

纯粹的形码（**纯形**），不依赖除字形外的其他信息来确定候选字的范围。也就是说，当出现一个新汉字时，只要知道它字形特征，就可以确定它的完整编码。

::: tip 方案举例

笔划输入法（笔划）、四角号码输入法（特征）、五笔字形输入法（部首、结构）、仓颉输入法（部首、特征）。

:::

### 1.3. 音形码

音形输入法，又称「音形码」，是指通过同时输入汉字的读音和字形特征来确定候选字范围的输入法。读音对应的编码在前，字形对应的编码在后。

音形输入法以音为主，以形为辅，部分情况下字形的部分只作为补充信息而被省略。

当出现一个新汉字时，只知道汉字的读音或字形特征，无法保证能够确定它的完整编码。

::: tip 方案举例

自然码辅助码、小鹤双形、声笔。

:::

### 1.4. 形音码

形音输入法，又称「形音码」，是指通过同时输入汉字的字形特征和读音来确定候选字范围的输入法。字形对应的编码在前，读音对应的编码在后。

音形输入法以形为主，以音为辅，部分情况下字音的部分只作为补充信息而被省略。

当出现一个新汉字时，只知道汉字的读音或字形特征，无法保证能够确定它的完整编码。

::: tip 方案举例

米十五笔、字源输入法。

:::

### 1.5. 混合码

混合编码输入法，是指一个汉字会使用两种或以上的编码方式。比如一个汉字既可以通过纯音方式输入，也可以通过纯形方式输入，也可以通过音形方式输入，也可以通过音形方式输入。

大部分的音形输入法或形音输入法都属于混合输入法。它们会提供两种及以上的编码方式，并在部分情况下回退化为纯音或纯形输入法。

::: tip 方案举例

两分输入法（大字集形码递归）

:::

### 1.6. 无理码

无理码输入法，是指输入的编码无法直接对应到汉字的读音或字形特征。每个汉字的编码都需要特殊记忆。

::: tip 方案举例

电报码，Unicode万国码。

:::

## 2. 编码属性

本节中，「汉字」可以是单个汉字，也可以是词语或短语，也可以是任何其他的字符。

### 2.1. 编码

编码，指的是一串字符序列，包括字母、数字、符号等。它们会对应到一个或多个汉字。

#### 2.1.1. 编码字符集合

编码字符集合，又称编码字符空间，指的是某一个输入法所使用的所有编码字符的集合。

::: tip 举例

五笔字形的编码集合为 a 到 y 的所有 25 个字母。

:::

#### 2.1.2. 编码空间

编码空间，指的是一个输入法中所有合法的编码的集合。

::: tip 举例

全拼输入法的编码空间包括所有合法的拼音，如 `pian`、`xian`、`hao` 等。`pian` 是合法的编码，而 `pianx` 则不是合法的编码。因此全拼的编码空间不包括 `pianx`。

:::

#### 2.1.3. 编码分割

编码分割，又称编码分离，是指输入法在输入时，将连续的编码字符串分割若干合法的编码（这些编码需在编码空间中）。

#### 2.1.4. 分割符

分割符，指的是用于分割编码的字符，它们往往不属于某输入方案的编码集合。使用分割符可以帮助输入法将连续的编码无歧义地分割成若干部分。

#### 2.1.5. 理论编码和实际编码

理论编码，指的是输入法在设计时所定义的编码方式。

实际编码，指的是用户在使用输入法时实际输入的编码。有时候，为了消除歧义，实际编码会与理论编码有所不同，比如使用额外的分隔符。

::: tip 举例

「西安」在全拼输入法中的的理论编码为 `xian`，实际编码可能是 `xian`（不进行手工分割），也可能是 `xi'an`（使用了单引号作为分隔符）。

:::

### 2.2. 「分割唯一」属性

分割唯一，是指输入法在输入时，可以将连续的编码分割为一种且唯一的方式，而不出现歧义。

::: tip 举例

假定空格键是分割符号，则输入连续编码 `ni hao shi jie` 时，编码会被分割为 `ni ` `hao ` `shi ` `jie ` 四个部分，并且分割方式是唯一的。

:::

### 2.3. 「分割不唯一」属性

分割不唯一，是指输入法在输入时，连续编码可以被分割为多种合法的编码组合，从而有可能产生歧义。具体的分割方法有可能会依赖于上下文或其他信息（联想）。

::: tip 举例

连续编码 `nihaoshijie` 时，编码可能会被分割为 `ni  hao  shi  jie` 四个部分，也可能被分割为  `ni  hao  shi  ji  e` 五个部分。两种分割方法都是合法的。

:::

### 2.4. 「前缀码」属性

前缀码，又称前置码，自由前缀码。是指任何一个汉字的编码都不是任何其他汉字编码的前若干码。

前缀码的编码分割是内向性的，也就是说当前编码自身可以确定它的结束，而不需要看到下一个有效编码。

::: tip 举例

一个前缀码方案中，日的编码为ri，则不存在任意一个编码，其前两码是ri。

一个方案中所有的编码都是以空格键结尾的，且空格键只作为结尾，则它具有前缀码属性。

:::

::: tip 方案举例

宇浩日月（同是为前缀码和定长码）。

:::

::: warning 相关属性

前缀码具有分割唯一属性。

**任何**定长码或变长码，如果在其编码后附加额外的分隔符号（如空格），则其编码具有前缀码属性。

:::

### 2.5. 「顶功」属性

顶功，是指一类可以通过匹配编码字符集合的**组合模式**而达到**唯一编码分割**的编码方式。

顶功码的编码分割是外向性的，也就是说需要看到下一个有效编码才能确定当前编码的结束。

::: tip 举例

举例一：某方案中，一个汉字的第一个编码，被设计为左手的按键，而剩余的编码被设计在右手上。这样的编码是否具有顶功属性？

这样的编码方式具有顶功属性。因为每当看到左手的按键时，就可以这是一个新汉字的开始码。

举例二：某方案中，一个汉字的前两码都是辅音字母，而剩余的编码是元音字母 `aeiou`。这样的编码是否具有顶功属性？

这样的编码方式具有顶功属性。因为每当看到两个辅音字母时，就可以确定这是一个新汉字的开始码。否则，它永远都是前一个汉字的后续码。

举例三：某方案中，一个汉字的编码要么是两个的字母，要么是三到四个字母加上一个空格键。这样的编码是否具有顶功属性？

这样的编码方式具有顶功属性。如果出现了连续四个字母，则观察第五码，如果它是空格键，则这是一个五码字的结束（四个字母加一个空格键）。如果第五码不是空格键，则其前两码构成一个两码字。

这种情况，我们需要往前看三码方能判断编码的分割情况。这个方案称为「五二顶」，也就是观察第五码来判断前两码是否可以唯一分割并上屏。

:::

::: warning 相关属性

顶功码具有分割唯一属性。

**任何**定长码或变长码，如果在其编码后附加额外的分隔符号（如空格），则其编码具有前缀码属性。

:::

关于更多顶功方面的相关信息，请移步《[顶功 · 集萃](https://ding.tansongchen.com/)》。

### 2.6. 「定长」属性

定长，指的是每个汉字的编码**最大**长度固定。也就是说，无论输入什么汉字，编码的最大长度都是一样的。当出现一个新的汉字时，它的最大长度是确定的。

::: tip 方案举例

五笔字形（最短编码长度为3，最长编码长度为4）、仓颉（最短编码长度为1，最长编码长度为5）。

:::

::: warning 相关属性

定长码不一定具有「分割唯一」的属性。

定长码通过添加分隔符号（如空格），可以在实际编码中达到「分割唯一」的属性。

:::

### 2.7. 「绝对定长」属性

绝对定长，是指编码的长度在所有情况下都是固定的。也就是说，无论输入什么汉字，编码的长度都是一样的。

::: tip 方案举例

双拼输入法。

:::

::: warning 相关属性

绝对定长码具有「分割唯一」的属性。

:::

### 2.8. 「可变长」属性

可变长码，又称变长码、不定长码，指的是编码长度不固定的输入法。也就是说，输入不同的汉字，编码的最大长度可能会有所不同。当出现一个新的汉字时，它的最大长度是不确定的。

::: tip 方案举例

笔划输入法、山人全息码。

:::

::: warning 相关属性

变长码不一定具有「分割唯一」的属性。

变长码通过添加分隔符号（如空格），可以在实际编码中达到「分割唯一」的属性。

:::

## 3. 上屏方式

### 3.1. 整句上屏

整句上屏，是指输入法在用户输入多个汉字后，将这些汉字一起上屏。

随著信息技术的不断发展，整句上屏往往配合输入联想功能，通过隐马尔可夫链、LLM等技术，实现对整句的预测。

### 3.2. 唯一上屏

唯一上屏，指的是当前输入的编码可以唯一确定为一个汉字（后选项为一）时，直接上屏该汉字。

唯一上屏的触发条件一定是内生的。也就是说，它不依赖下一个汉字的编码来确定当前汉字编码的结束。它包括：

1. 当前编码的长度达到最大长度；
1. 前缀码最后一码的编码字符出现。
1. 虽然存在后续编码空间，但已无其他汉字在预测区。

::: tip 举例

一个输入法的编码最大码长为4，当用户输入的编码为`abcd`，且这个编码对应了唯一字符（如`漢`），则直接上屏`漢`。

:::

::: tip 方案举例

三码郑码（六码除重模式）。该模式下，编码为不定长状态。当用户输入的单字编码构成唯一的汉字候选项且无后续预测（未成词），则直接上屏；当用户输入的单字编码参与了后续预测（成词），则不直接上屏，而是等待用户输入更多的编码字符判断是否上屏词语或是单字。

:::

### 3.3. 空格上屏

空格上屏，是指在编码后添加空格键，表示当前编码已经完成，并将首选项上屏。

空格键本身不上屏任何符号，而是将一个方案的实际编码转换为**前缀码**。因此，空格上屏可以视为一种特殊的「唯一确定上屏」。

### 3.4. 选重上屏

选重上屏，是指在用户输入编码后，通过选择候选字来确定上屏的汉字。

选充键本身不上屏任何符号，而是将一个方案的实际编码转换为**前缀码**。因此，选重上屏可以视为一种特殊的「唯一确定上屏」。但这种所谓「唯一确定」是在实际输入过程当中及时更新的，不具备通用的预见性。

### 3.5. 延迟上屏

延迟上屏，是指在用户输入编码且达到唯一分割条件是，不立即上屏，而是等待用户继续输入更多的编码字符后再上屏。

延迟上屏时，候选项可能唯一，也可能不唯一。

延迟上屏的触发条件一定是内生的。也就是说，它不依赖下一个汉字的编码来确定当前汉字编码的结束。它包括：

1. 当前编码的长度达到最大长度；
1. 前缀码最后一码的编码字符出现。

延迟上屏可以防止用户输入全码后自动上屏，从而避免输入错误无法回改的情况。

::: tip 方案举例

RIME 输入法将 `auto_select` 设置为 `false`，则在输入编码后不会立即上屏，而是等待用户继续输入一个字符后上屏前字。

:::

### 3.6. 顶功上屏

顶功上屏，是指在用户输入编码时，前若干码可以确定为唯一分割，则直接上屏其对应的候选汉字，并且保留剩余编码在输入区。

顶功上屏时，唯一确定的编码分割所对应的汉字可以是唯一候选，也可以是多个候选。但一般顶出首选。

顶功上屏的触发条件一定是外生的。也就是说，它必须依赖下一个（或几个）汉字的编码来确定当前汉字编码的结束。它包括：

1. 当前编码的字符集合的组合模式达到了唯一编码分割，可以确定一个汉字编码的结束；
1. 当输入某一编码时，本编码的所有后缀都不在合法的编码空间中，则立刻上屏前续编码对应的首选（包括预测项），且保留最后一码。

### 3.7. 符号上屏

符号上屏，是指在输入编码后输入标点符号，将当前第一候选字和符号同时上屏。

符号键本身不仅上屏前字，同时也上屏了符号本身。因此它可以根据具体情况视为以下上屏方式的一种特例：

1. 如果前续编码已经形成唯一分割，则符号上屏可以视为「延迟上屏」的一种。
1. 如果前续编码未形成唯一分割，则符号上屏可以视为「顶功上屏」的一种。此时，符号键会将实际编码转换为具有顶功属性的编码，实现了顶功输出。

## 4. 编码冲突

### 4.1. 重码

重码，又称编码冲突，是指两个或多个汉字的编码相同。

### 4.2. 选重

选重，是指在输入法中，当用户输入的编码对应多个候选汉字时，通过选择候选汉字来确定上屏的汉字。选重方法包括数字选择、符号选择、鼠标选择等。

### 4.3. 静态重码数

静态重码数，又称「绝对重码数」「静重」，指的是在一个字符集中，**编码完全相同的汉字的数量**。它不包含关于字频的信息，因此，静态重码只关注编码的唯一性。

注意，静态重码必须依赖于某一字集，字集的不同会导致静态重码数的不同。

::: details 静态重码数的计算公式和代码

假设 $Z$ 为一个汉字的集合，$M$ 为一个编码的集合。汉字 $z_{ij}$ 定义为编码为 $m_i$ 的第 $j$ 个汉字，顺序随机。那么，静态重码数可以表达为：

$$N_{s} = \mid \{z_{ia}, z_{ib}  \text{ if } M(z_{ia}) = M(z_{ib}) \text{ for all } a,b \in J_i \text{ and } i \in I \}.$$

以下为 Python 代码示例，使用 numpy 包计算静态重码数：

```python
import numpy as np
import typing
import numpy.typing as npt

def get_static_dup_rate(
    char: npt.NDArray[np.dtype("<U1")],
    code: npt.NDArray[np.dtype("<U4")],
    charset: typing.Sequence,
) -> int:
    """计算某个字集内的静态重码数

    Args:
        char (npt.NDArray[np.dtype): 元素为汉字。
        code (npt.NDArray[np.dtype): 元素为编码。
        charset (typing.Sequence): 字集。元素为汉字。比如通规汉字或 GBK.

    Returns:
        int: 静态重码数：
    """
    idx_char_in_scope = np.isin(char, charset)
    _, dup_counts = np.unique(code[idx_char_in_scope], return_counts=True)
    return dup_counts[dup_counts > 1].sum()
```

:::

### 4.4. 静态重码组数

静态重码组数，指的是在一个字符集中，**编码完全相同的汉字组数**。

由于部分编码可能对应超过两个汉字，因此以下不等式成立：

$$
静态重码数 \ge 静态重码组数 \times 2
$$

### 4.5. 静态选重数

静态选重数，指的是在一个字符集中，**编码完全相同、且不为首选的汉字数量**。以下等式成立：

$$
静态选重数 = 静态重码数 - 静态重码组数
$$

### 4.6. 静态选重率

静态选重率，是指在一个字符集中，**编码完全相同、且不为首选的汉字数量**与**字集包含字数**之比。它可以表达为：

$$
静态选重率 = \frac{静态选重数}{字集包含汉字数量}
$$

### 4.7. 动态重码率

动态重码率，又称「动重」「字频加权选重率」，是指编码完全相同、且不为首选的汉字的出现频率。它可以表达为：

$$

动态重码率 = \sum_i (需要选重的汉字_i \times 汉字出现频率_i)

$$

::: details 动态重码率的计算公式和代码

假设 $Z$ 为一个汉字的集合，$M$ 为一个编码的集合，$p:Z\rightarrow [0,1]$ 为汉字到其出现频率的映射。用编码和字频对汉字排序，使汉字 $z_{ij}$ 是编码为 $m_i$ 的第 $j$ 个汉字，$i \in I$, $j \in J_i$, 且满足 $a\geq b$ 时，$f(z_{ia})\geq f(z_{ib})$。
动态选重率可以表达为：

$$N_{d} = \sum\limits_{i \in I, j \in J_i/\{1\}} p(z_{ij}).$$

```python
def get_dynamic_dup_rate(
    code: npt.NDArray[np.dtype("<U4")],
    freq: npt.NDArray,
    idx_sorted_freq: npt.NDArray[np.dtype("i")],
) -> float:
    """计算字频加权选重率（动态重码率）

    Args:
        code (npt.NDArray[np.dtype): 元素为汉字对应的编码。
            宇浩输入法编码不超过四位，所以编码的格式是 4 个 Unicode 组成的字符串。
        freq (npt.NDArray): 元素为汉字对应的字频。
        idx_sorted_freq (npt.NDArray[np.dtype): 根据字频进行降序排列的索引。
            一般的：idx_sorted_freq = np.argsort(-freq)
            因为这一项操作只需要进行一次，故而不需要放入函数中循环。
    Returns:
        float: 字频加权选重率。
    """
    # 字频降序后的编码和字频列表
    code = code[idx_sorted_freq]
    freq = freq[idx_sorted_freq]
    # 得到第一个非重复的编码的索引
    _, idx_unique_freq = np.unique(code, return_index=True)
    # 生成一个掩码层，将重复的编码筛出
    duplicated_mask = np.full(freq.shape, True)
    duplicated_mask[idx_unique_freq] = False
    # 重复的编码，就是需要选重的字
    # 将这些重复的编码所对应的字频进行求和
    return freq[duplicated_mask].sum()
```

:::
