import{_ as c}from"./chunks/Chaifen.vue_vue_type_script_setup_true_lang.DgF6BSeS.js";import{c as t,m as o,J as l,a as e,a4 as s,o as d}from"./chunks/framework.vM2YJXtg.js";const a=o("h1",{id:"单字拆分",tabindex:"-1"},[e("单字拆分 "),o("a",{class:"header-anchor",href:"#单字拆分","aria-label":'Permalink to "单字拆分"'},"​")],-1),_=o("h2",{id:"汉字拼图",tabindex:"-1"},[e("汉字拼图 "),o("a",{class:"header-anchor",href:"#汉字拼图","aria-label":'Permalink to "汉字拼图"'},"​")],-1),i=o("p",null,"先前说过，拆字，就是把汉字按照一定的规则，拆成唯一的字根组合。这个过程如同拼图一般，大多数时候，是非常直观而自然的。",-1),n={class:"tip custom-block"},r=o("p",{class:"custom-block-title"},"例",-1),p={class:"flex justify-left flex-wrap"},h=o("p",null,"这种将字拆成直观的、分离的部件的方法，足以应付大部分汉字的拆分了。但在实际使用中，遇到这个问题：一个独体字，本身不是字根，怎么办？这时候，我们要把它继续拆成更小的字根甚至笔划。",-1),u={class:"tip custom-block"},f=s('<p class="custom-block-title">例</p><p><code>戋</code>这个字，我们可以继续将它拆成<code>一</code>和<code>戈</code>。查字根图可知，<code>一</code>和<code>戈</code>正好是两个字根，拆字成功。</p><p><code>丸</code>这个字，我们可以继续将它拆成<code>九</code>和<code>丶</code>。查字根图可知，<code>九</code>和<code>丶</code>正好是两个字根，拆字成功。</p><p><code>朱</code>这个字，我们可以继续将它拆成<code>牛</code>和<code>八</code>。查字根图可知，<code>牛</code>和<code>八</code>正好是两个字根，拆字成功。</p>',4),T={class:"flex justify-left flex-wrap"},x=o("p",null,[e("有时候，独体字的拆分不是很直观。比如"),o("code",null,"再"),e("可以拆成"),o("code",null,"一冂土"),e("，也可以拆成"),o("code",null,"王冂"),e("。遇到此类字时的拆分，往往需要一些经验和练习。所以当你遇到不会拆的字时，应该主动查询它的编码，及时学习。")],-1),m=o("p",null,[e("更麻烦的情况是，"),o("strong",null,"一个字好像有几种拆分方法"),e("。")],-1),b={class:"tip custom-block"},k=o("p",{class:"custom-block-title"},"例",-1),v=o("p",null,[o("code",null,"井"),e("，可以拆"),o("code",null,"二{介下}"),e("，也可以拆"),o("code",null,"一廾"),e("。")],-1),P={class:"flex justify-left flex-wrap"},S=o("p",null,[o("code",null,"单"),e("可以拆成"),o("code",null,"丷日十"),e("也可以拆成"),o("code",null,"丷冂丰"),e("。")],-1),A={class:"flex justify-left flex-wrap"},V=o("p",null,[o("code",null,"主"),e("可以拆成"),o("code",null,"丶王"),e("也可以拆成"),o("code",null,"亠土"),e("。")],-1),y={class:"flex justify-left flex-wrap"},j=s('<p>这种一字多拆的情况，任何形码中，都是希望避免的。因为一字多拆，会造成极大的不确定性，并造成编码的混乱<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>宇浩输入法总结了拆字规则，并且不断自我审视每一个拆分是否符合规则。通过大量的努力，明确了一套优先级系统。使每一个汉字，都有唯一的拆分方案，消除了不确定性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><div class="info custom-block"><p class="custom-block-title">拆字优先级</p><p>「宇浩」拆字规则，按优先级排序如下：</p><ol><li>字根最少</li><li>结构完整</li><li>符合笔顺</li><li>散连交断</li><li>字根取大</li></ol><p>以上优先级，还可以高度归纳为：<strong>少整顺散连交断大</strong>。</p></div><p>取根时，如果有多种不同的拆分方式，则按<strong>优先级从高到低</strong>依次检查以上规则，选取符合条件的，排除不满足的，最终得到唯一的拆分方案。因此，某种意义上来说，宇浩输入法的拆分规则，其实是一种「比较和淘汰」的排除法，后文中会展示这些步骤的机器实现。</p><p>以下为拆分规则详细介绍<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p><h2 id="字根最少" tabindex="-1">字根最少 <a class="header-anchor" href="#字根最少" aria-label="Permalink to &quot;字根最少&quot;">​</a></h2><p>字根最少，意思是拆分一个字时，应该使得字根的数量最少。保证字根数量最少，是第一优先级最高的规则。</p>',7),w={class:"tip custom-block"},C=o("p",{class:"custom-block-title"},"例",-1),I=o("p",null,[o("code",null,"国"),e("如果完全符合笔顺，应该拆成"),o("code",null,"冂王丶一"),e("，是四个字根。但拆成"),o("code",null,"囗王丶"),e("，只用三个字根就够了。因为「少」优先级高于「顺」，所以应该拆成"),o("code",null,"囗王丶"),e("。")],-1),q={class:"flex justify-left flex-wrap"},N=o("p",null,[o("code",null,"國"),e("如果完全符合笔顺，应该拆成"),o("code",null,"冂一口一丿丶一"),e("，是七个字根。但拆成"),o("code",null,"囗戈口一"),e("，只用四个字根就够了。因为「少」优先级高于「顺」，所以应该拆成"),o("code",null,"囗戈口一"),e("。")],-1),D={class:"flex justify-left flex-wrap"},E=o("h2",{id:"结构完整",tabindex:"-1"},[e("结构完整 "),o("a",{class:"header-anchor",href:"#结构完整","aria-label":'Permalink to "结构完整"'},"​")],-1),R=o("p",null,[e("结构完整，指的是"),o("code",null,"囗日目勹冂匚コ凵"),e("等存在全包围和半包围结构的字根不拆散。")],-1),g=o("p",null,"这个原则的设置，是为了不过分破坏汉字的整体性和直观性。",-1),B={class:"tip custom-block"},J=o("p",{class:"custom-block-title"},"例",-1),O=o("p",null,[o("code",null,"昜"),e("拆"),o("code",null,"日一勹彡"),e("不拆"),o("code",null,"日丆𠃌彡"),e("。")],-1),$={class:"flex justify-left flex-wrap"},z=o("p",null,[o("code",null,"单"),e("可以拆成"),o("code",null,"丷日十"),e("也可以拆成"),o("code",null,"丷冂丰"),e("。两者都是三根。因为包围结构不拆散，故而"),o("code",null,"单"),e("拆成"),o("code",null,"丷日十"),e("。")],-1),F={class:"flex justify-left flex-wrap"},G=o("p",null,[o("code",null,"免"),e("可以拆成"),o("code",null,"⺈口儿"),e("也可以拆成"),o("code",null,"⺈冂尢"),e("。两者都是三根。因为包围结构不拆散，故而"),o("code",null,"免"),e("拆成"),o("code",null,"⺈口儿"),e("。")],-1),H={class:"flex justify-left flex-wrap"},K=o("p",null,[o("code",null,"万"),e("拆成"),o("code",null,"一勹"),e("而非"),o("code",null,"{一丿}乛"),e("。因为前者不仅完全符合笔顺，同时也保持了结构完整。")],-1),L={class:"flex justify-left flex-wrap"},M=o("p",null,[o("code",null,"匹"),e("拆"),o("code",null,"匚儿"),e("而不拆"),o("code",null,"兀乚"),e("，因为前者结构完整。")],-1),Q={class:"flex justify-left flex-wrap"},U=s('<h2 id="符合笔顺" tabindex="-1">符合笔顺 <a class="header-anchor" href="#符合笔顺" aria-label="Permalink to &quot;符合笔顺&quot;">​</a></h2><p>注意到，为了使字根数量较少，某些大于等于两划的字根，它的笔顺可能会被另一个或多个字根穿插打断。比如<code>固</code>字拆<code>囗古</code>时，<code>囗</code>不是一次性写完，而是分成俩次写完的。</p><p>符合笔顺，指的是字根之间不穿插写成<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。它有两种情况：</p><ul><li>整体符合笔顺：指一个字完全按照笔顺写成，字根间不会互相干扰笔顺。<code>固</code>字如拆<code>冂古一</code>，便算作整体符合笔顺。</li><li>局部符合笔顺：指一个字虽不能完全按照笔顺写成，但局部字根符合笔顺。<code>固</code>字如拆<code>囗古</code>，便算作局部符合笔顺，且符合笔顺的有一个字根「古」，共五画。</li></ul><p>「符合笔顺」规则，指一个字是否整体符合笔顺（后面的「取大」规则中，会继续判断局部符合笔顺的字根数量）。</p><p>符合笔顺的优先级低于字根最少。</p>',6),W={class:"tip custom-block"},X=o("p",{class:"custom-block-title"},"例",-1),Y=o("p",null,[o("code",null,"来"),e("可以拆成"),o("code",null,"一米"),e("也可以拆成"),o("code",null,"未丷"),e("，都是两根，但拆成"),o("code",null,"一米"),e("完全符合笔顺。")],-1),Z={class:"flex justify-left flex-wrap"},oo=o("p",null,[o("code",null,"聿"),e("可以拆成"),o("code",null,"彐キ"),e("也可以拆成"),o("code",null,"肀二"),e("，都是两根，但拆成"),o("code",null,"彐キ"),e("完全符合笔顺。")],-1),eo={class:"flex justify-left flex-wrap"},co=s('<h2 id="散连交断" tabindex="-1">散连交断 <a class="header-anchor" href="#散连交断" aria-label="Permalink to &quot;散连交断&quot;">​</a></h2><p><strong>散·连·交·断</strong>，是汉字部首或笔画的四种状态。</p><ul><li>字根离散，指的是两个字根互相分离。比如<code>部</code>中的<code>立口阝</code>，便是三个分离的字根。</li><li>字根相连，指的是两个字根互相连接。比如<code>美</code>拆为<code>𦍌大</code>，这两个字根是相连的。</li><li>字根相交，指的是两个字根互相交叉。比如<code>再</code>拆成<code>一冂土</code>三个字根，便是相交的。</li><li>笔划断开，指的是一个笔划（横或竖）断开。比如<code>我</code>拆成<code>丿扌戈</code>三个字根，其中的<code>扌</code>和<code>戈</code>两根的横本是一笔写成，但我们将横画断开。</li></ul><p>「散连交断」，优先级依次下降，但都排在「字根最少」「结构完整」「符合笔顺」之后。</p><h3 id="能散不连" tabindex="-1">能散不连 <a class="header-anchor" href="#能散不连" aria-label="Permalink to &quot;能散不连&quot;">​</a></h3><p>两个字根互相分离，优于两个字根互相连接。</p>',6),lo={class:"tip custom-block"},so=o("p",{class:"custom-block-title"},"例",-1),to=o("p",null,[o("code",null,"主"),e("可以拆成"),o("code",null,"丶王"),e("也可以拆成"),o("code",null,"亠土"),e("。观察到，"),o("code",null,"丶王"),e("是散开的，而"),o("code",null,"亠土"),e("是相连的，后者符合「能散不连」。")],-1),ao={class:"flex justify-left flex-wrap"},_o=o("h3",{id:"能连不交",tabindex:"-1"},[e("能连不交 "),o("a",{class:"header-anchor",href:"#能连不交","aria-label":'Permalink to "能连不交"'},"​")],-1),io=o("p",null,"两个字根互相分离，优于两个字根互相交叉。",-1),no={class:"tip custom-block"},ro=o("p",{class:"custom-block-title"},"例",-1),po=o("p",null,[o("code",null,"开"),e("可以拆成"),o("code",null,"一廾"),e("也可以拆成"),o("code",null,"二{介下}"),e("。观察到，第一种拆法字根相连，第二种拆法字根相交。故而拆成"),o("code",null,"一廾"),e("符合「能连不交」。")],-1),ho={class:"flex justify-left flex-wrap"},uo=o("h3",{id:"能交不断",tabindex:"-1"},[e("能交不断 "),o("a",{class:"header-anchor",href:"#能交不断","aria-label":'Permalink to "能交不断"'},"​")],-1),fo=o("p",null,"两个字根互相交叉，优于将笔画断开。",-1),To={class:"tip custom-block"},xo=s('<p class="custom-block-title">例</p><p><code>果</code>拆作<code>日木</code>，不拆成<code>田木</code>或<code>甲木</code>，这是因为后者将中间的竖断开了。因为「字根相交」的优先级高于「笔画断开」，<code>果</code>应当拆成<code>日木</code>。</p>',2),mo={class:"flex justify-left flex-wrap"},bo=s('<h3 id="根少而断" tabindex="-1">根少而断 <a class="header-anchor" href="#根少而断" aria-label="Permalink to &quot;根少而断&quot;">​</a></h3><p>为了根少和直观，有且只有以下两种情况可以断开笔画：</p><ol><li><code>我識羲</code>等字中<code>戈</code>的横。</li><li><code>重熏</code>等字中<code>千</code>的竖。</li></ol>',3),ko={class:"tip custom-block"},vo=o("p",{class:"custom-block-title"},"例",-1),Po=o("p",null,[o("code",null,"我"),e("拆作"),o("code",null,"丿扌戈"),e("，不拆成"),o("code",null,"丿扌乚丿丶"),e("。虽然前者将中间的横断开了，但因为「字根最少」，我们选择只有三根的"),o("code",null,"丿扌戈"),e("。")],-1),So={class:"flex justify-left flex-wrap"},Ao=o("p",null,[o("code",null,"熏"),e("拆作"),o("code",null,"千黑"),e("，不拆成"),o("code",null,"千囗丷二灬"),e("。虽然前者将中间的竖断开了，但因为「字根最少」，我们选择只有两根的"),o("code",null,"千黑"),e("。")],-1),Vo={class:"flex justify-left flex-wrap"},yo=s('<h2 id="字根取大" tabindex="-1">字根取大 <a class="header-anchor" href="#字根取大" aria-label="Permalink to &quot;字根取大&quot;">​</a></h2><p>字根取大，指的是按照笔顺拆字时：</p><ul><li>让非「竖·撇变形部分」尽可能地大。</li><li>让首笔靠前的字根尽可能地大。</li></ul><h3 id="非变形部分取大" tabindex="-1">非变形部分取大 <a class="header-anchor" href="#非变形部分取大" aria-label="Permalink to &quot;非变形部分取大&quot;">​</a></h3><p>部分字根在做偏旁的时候，由于书法的考虑，会有「竖变撇」「撇变竖」的变化。它们称为「竖·撇变形根」。</p><div class="info custom-block"><p class="custom-block-title">竖·撇变形根</p><p><code>千</code>字根的<code>丨</code>变成<code>丿</code></p><p><code>干</code>字根的<code>丨</code>变成<code>丿</code></p><p><code>キ</code>字根的<code>丨</code>变成<code>丿</code></p><p><code>丰</code>字根的<code>丨</code>变成<code>丿</code></p><p><code>羊</code>字根的<code>丨</code>变成<code>丿</code></p><p><code>丌</code>字根的<code>丿</code>变成<code>丨</code></p></div><p>我们应当对非变形部分取大。</p>',7),jo={class:"tip custom-block"},wo=o("p",{class:"custom-block-title"},"例",-1),Co=o("p",null,[o("code",null,"失"),e("拆"),o("code",null,"丿夫"),e("而不拆"),o("code",null,"牛乀"),e("，因为"),o("code",null,"牛"),e("的一竖是撇。故而对"),o("code",null,"夫"),e("取大。")],-1),Io={class:"flex justify-left flex-wrap"},qo=o("p",null,[o("code",null,"井"),e("拆"),o("code",null,"二{介下}"),e("而不拆"),o("code",null,"キ丨"),e("，因为"),o("code",null,"キ"),e("的一竖是撇。故而对"),o("code",null,"{介下}"),e("取大。")],-1),No={class:"flex justify-left flex-wrap"},Do=s('<p><code>严</code>拆为<code>一业丿</code>，而不拆成<code>丌丷厂</code>，因为后者中，<code>丌</code>字根的<code>丿</code>变成<code>丨</code>。为了让非「竖·撇变形根」尽可能地大，我们取<code>业</code>根。</p><p>另外一种拆法<code>丌䒑丿</code>不取的原因是<code>䒑</code>字根中的点应当和横相连（艹字头的行书写法），而<code>严</code>字中两点分散了。这违反了<a href="./intrinsic.html">字根的内在属性</a>。</p>',2),Eo={class:"flex justify-left flex-wrap"},Ro=o("p",null,[o("code",null,"缓"),e("拆"),o("code",null,"纟爪干又"),e("而不拆"),o("code",null,"纟爪二夂"),e("。虽然前者"),o("code",null,"干"),e("的竖是撇，但后者出现了「字根相交」。根据规则优先级，「字根相交」低于「字根相连」，故而拆为"),o("code",null,"纟爪干又"),e("。")],-1),go={class:"flex justify-left flex-wrap"},Bo=s('<h3 id="不对称部分取大" tabindex="-1">不对称部分取大 <a class="header-anchor" href="#不对称部分取大" aria-label="Permalink to &quot;不对称部分取大&quot;">​</a></h3><p>部分字根在做独体字时，会有不对称的情况。我们应对不对称部分取大。</p><p>此规则只出现于大字集中。</p><div class="tip custom-block"><p class="custom-block-title">例</p><p><code>宺</code>拆<code>宀口一𫶧</code>而不拆<code>宀口丌乚</code>，因为拆为<code>丌乚</code>破坏了字根<code>丌</code>的对称性。</p></div><h3 id="向前取大" tabindex="-1">向前取大 <a class="header-anchor" href="#向前取大" aria-label="Permalink to &quot;向前取大&quot;">​</a></h3><p>向前取大，让首笔靠前的字根的笔划数尽量地多。这是一个兜底原则，可以保证最终只有一个候选方案能够胜出。因此，它的优先级必然是所有拆字规则中最低的。</p>',6),Jo={class:"tip custom-block"},Oo=o("p",{class:"custom-block-title"},"例",-1),$o=o("p",null,[o("code",null,"夬"),e("拆为"),o("code",null,"ユ人"),e("，而不拆成"),o("code",null,"乛大"),e("，因为「字根取大」原则。让首笔靠前的字根的笔划数尽量地多，这里，"),o("code",null,"ユ"),e("的笔画数大于"),o("code",null,"乛"),e("。")],-1),zo={class:"flex justify-left flex-wrap"},Fo=o("p",null,[o("code",null,"丈"),e("拆为"),o("code",null,"𠂇丶"),e("，而不拆成"),o("code",null,"一乂"),e("，因为「字根取大」原则。让首笔靠前的字根的笔划数尽量地多，这里，"),o("code",null,"𠂇"),e("的笔画数大于"),o("code",null,"一"),e("。")],-1),Go={class:"flex justify-left flex-wrap"},Ho=s('<h2 id="拆字举例" tabindex="-1">拆字举例 <a class="header-anchor" href="#拆字举例" aria-label="Permalink to &quot;拆字举例&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">更多例字</p><p>想要了解更多具有代表性的例字在宇码中的拆分，请参见<a href="./examples.html">字海拾珍——必拆字举隅</a>。</p><p>如果你想了解使用频率最为靠前的几百个汉字在宇码中的拆分，可以点击进入<a href="./frequent.html">高频字拆分图解（简化字）</a>或<a href="./frequent_tc.html">高频字拆分图解（传统字）</a>页面。</p></div><p>实际拆字时，如果你感觉拆分方法不唯一，那么可以用以下方法找到最优解：</p><ul><li>列出所有可能的候选拆分方案。</li><li>依照「少整顺散连交断大」的规则顺序，依次比较各个候选拆分。</li><li>如果所有的候选拆分都不满足本条规则，则进入下条规则。</li><li>如果部分的候选拆分满足本条规则，则该部分的候选拆分方案进入下条规则。</li><li>直到只有一个候选拆分方案胜出。</li></ul><p>以下通过部分例字来说明拆分规则：</p>',5),Ko={class:"tip custom-block"},Lo=o("p",{class:"custom-block-title"},"例",-1),Mo=s("<li>一例：<code>亷</code>。候选拆分<code>亠丷厂彐〢八</code>和<code>立丿彐〢八</code>。 <ul><li><code>亠丷厂彐〢八</code>六根，<code>立丿彐〢八</code>五根。后者字根最少，直接胜出。</li></ul></li><li>又一例：<code>重</code>。候选拆分<code>丿車一</code>和<code>千里</code>。 <ul><li><code>千里</code>是两根，满足「字根最少」，直接虽然中间一竖断开，但依然胜出。</li></ul></li>",2),Qo=o("code",null,"盡",-1),Uo=o("code",null,"コ土灬皿",-1),Wo=o("code",null,"乛龶灬皿",-1),Xo=o("code",null,"彐丄灬皿",-1),Yo=o("code",null,"{聿上}一灬皿",-1),Zo=o("ul",null,[o("li",null,"都是四根，同时满足「字根最少」。"),o("li",null,[o("code",null,"コ土灬皿"),e("不符合笔顺，其他三者都完全符合笔顺。淘汰"),o("code",null,"コ土灬皿"),e("。")]),o("li",null,"上半部分都出现字根相交情况。"),o("li",null,"都不适用「结构合理」。"),o("li",null,[e("进入兜底规则「字根取大」。根据规则，只要其中某个字根多写一笔仍然符合笔顺，就多写一笔。观察到，"),o("code",null,"{聿上}一灬皿"),e("的第一根一共写了四笔，故而胜出。")])],-1),oe={class:"flex justify-left flex-wrap"},ee=o("code",null,"曱",-1),ce=o("code",null,"甴",-1),le=s("<ul><li><code>曱</code>按笔顺取大，故而是<code>日丨</code>。</li><li><code>甴</code>，候选拆分为<code>日丨</code> <code>囗丄</code>。两者都是两根，都结构完整。按笔顺取大，故而是<code>日丨</code>。</li></ul>",1),se={class:"flex justify-left flex-wrap"},te=s('<p>上面的例子逻辑虽比较复杂，但是最终的结果还是非常直观的。在宇浩输入法中，大多数的时候，直观的拆分方法往往也是符合规则的。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>前辈输入法的拆字规则，一般都有诸如「直观」、「符合笔顺」、「取大」等设置。但是优先级往往不够明确，很多拆分方法并不符合规则，存在不少特例。在常用字范围内，还可以通过大量练习来完成记忆，但到了大字集，规则不明确、规则相矛盾，都是造成检字困难的因素。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>当然，汉字不是完全可以量化的，不同字形下，也会出现不同的拆分可能。除了良好的定义外，有时候比例原则也很重要。尤其在大字集上，追求单一拆分方法会扭曲汉字直观性，不能兼顾不同字形，让使用者需要大量尝试才能找到想要的字，这违背了大字集检字的初衷。因此，对于大字集，也会设置兼容拆分和容错码。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>在进行拆分前，首先需要「确认」某个字根到底存不存在，是否合规，也就是检查字根的「内在属性」。比如<code>土</code> <code>士</code>，两横的长度直接决定了字根的异同。其次需要检查一些「拆分禁手」，比如<code>王</code>中间如果被笔画「穿心」，这是不被允许的。禁手有：散件不分割、竖向不包夹、横间不穿心。对这两点的讨论作为进阶内容，于此处跳过。若有兴趣，可以在后续章节 《进阶讨论》中阅读。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>为什么要有完全合笔顺这个规则，而且优先级那么高？在我的认知中，形码的基本出发点就是如同写字一样输入一系列笔画，即「五笔画输入法」。它是最自然，最直观的，所以宇码规则有了「符合笔顺」。但是，输入讲求效率，必须把一些笔画合并起来形成字根，它们的笔顺可能会相互穿插，所以要有「根少优先」这个规则，把它的优先级放在了「符合笔顺」的前面。最后，需要有个兜底条款「向前取大」来保证没有拆分歧义。因此，形码拆分有了「根少」「笔顺」「取大」，其实已经足够了。接下来的其他规则都是在这上面打补丁，为了让拆分更加「直观」。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>',3),pe=JSON.parse('{"title":"单字拆分","description":"","frontmatter":{},"headers":[],"relativePath":"learn/division.md","filePath":"learn/division.md"}'),de={name:"learn/division.md"},he=Object.assign(de,{setup(ae){return(_e,ie)=>(d(),t("div",null,[a,_,i,o("div",n,[r,o("div",p,[l(c,{char:"糧",parts:[6,4,1,7]}),l(c,{char:"錘",parts:[8,3,4,1]}),l(c,{char:"錢",parts:[8,4,4]}),l(c,{char:"瓶",parts:[3,3,4]}),l(c,{char:"琴",parts:[4,4,2,1,1]}),l(c,{char:"鴿",parts:[6,11]})])]),h,o("div",u,[f,o("div",T,[l(c,{char:"戋",parts:[1,4]}),l(c,{char:"丸",parts:[2,1]}),l(c,{char:"朱",parts:[4,2]})])]),x,m,o("div",b,[k,v,o("div",P,[l(c,{char:"井",parts:[1,3]}),e(" ❓ "),l(c,{char:"井",parts:[2,2]}),e(" ❓ "),l(c,{char:"井",parts:[3,1]}),e(" ❓ ")]),S,o("div",A,[l(c,{char:"单",parts:[2,4,2]}),e(" ❓ "),l(c,{char:"单",parts:[2,2,1,1,2],colors:[1,2,3,2,3]}),e(" ❓ "),l(c,{char:"单",parts:[2,2,4]}),e(" ❓ ")]),V,o("div",y,[l(c,{char:"主",parts:[1,4]}),e(" ❓ "),l(c,{char:"主",parts:[2,3]}),e(" ❓ "),l(c,{char:"主",parts:[1,3,1],colors:[1,2,1]}),e(" ❓ ")])]),j,o("div",w,[C,I,o("div",q,[l(c,{char:"国",parts:[2,4,1,1],colors:[1,2,3,1]}),e(" ✅ "),l(c,{char:"国",parts:[2,4,1,1]}),e(" ❌ ")]),N,o("div",D,[l(c,{char:"國",parts:[2,1,3,1,3,1],colors:[1,2,3,4,2,1]}),e(" ✅ "),l(c,{char:"國",parts:[2,1,3,1,1,1,1,1]}),e(" ❌ ")])]),E,R,g,o("div",B,[J,O,o("div",$,[l(c,{char:"昜",parts:[4,1,2,2]}),e(" ✅ "),l(c,{char:"昜",parts:[4,2,1,2]}),e(" ❌ ")]),z,o("div",F,[l(c,{char:"单",parts:[2,4,2]}),e(" ✅ "),l(c,{char:"单",parts:[2,2,4]}),e(" ❌ ")]),G,o("div",H,[l(c,{char:"免",parts:[2,3,2]}),e(" ✅ "),l(c,{char:"免",parts:[2,2,3]}),e(" ❌ ")]),K,o("div",L,[l(c,{char:"万",parts:[1,2]}),e(" ✅ "),l(c,{char:"万",parts:[1,1,1],colors:[1,2,1]}),e(" ❌ ")]),M,o("div",Q,[l(c,{char:"匹",parts:[1,2,1],colors:[1,2,1]}),e(" ✅ "),l(c,{char:"匹",parts:[3,1]}),e(" ❌ ")])]),U,o("div",W,[X,Y,o("div",Z,[l(c,{char:"来",parts:[1,6]}),e(" ✅ "),l(c,{char:"来",parts:[1,2,4],colors:[1,2,1]}),e(" ❌ ")]),oo,o("div",eo,[l(c,{char:"聿",parts:[3,3]}),e(" ✅ "),l(c,{char:"聿",parts:[3,2,1],colors:[1,2,1]}),e(" ❌ ")])]),co,o("div",lo,[so,to,o("div",ao,[l(c,{char:"主",parts:[1,4]}),e(" ✅ "),l(c,{char:"主",parts:[2,3]}),e(" ❌ ")])]),_o,io,o("div",no,[ro,po,o("div",ho,[l(c,{char:"开",parts:[1,3]}),e(" ✅ "),l(c,{char:"开",parts:[2,2]}),e(" ❌ ")])]),uo,fo,o("div",To,[xo,o("div",mo,[l(c,{char:"果",parts:[4,4]}),e(" ✅ "),l(c,{char:"果",parts:[4,1,1,2],colors:[1,2,0,2]}),e(" ❌ ")])]),bo,o("div",ko,[vo,Po,o("div",So,[l(c,{char:"我",parts:[1,1,2,3],colors:[1,0,2,3,5,1]}),e(" ✅ "),l(c,{char:"我",parts:[1,3,1,1,1]}),e(" ❌ ")]),Ao,o("div",Vo,[l(c,{char:"熏",parts:[2,5,1,6],colors:[1,2,0,2,3,5,1]}),e(" ✅ "),l(c,{char:"熏",parts:[2,2,2,1,1,2,4],colors:[1,2,3,2,1,4,5]}),e(" ❌ ")])]),yo,o("div",jo,[wo,Co,o("div",Io,[l(c,{char:"失",parts:[1,4]}),e(" ✅ "),l(c,{char:"失",parts:[4,1],colors:[1,2]}),e(" ❌ ")]),qo,o("div",No,[l(c,{char:"井",parts:[2,2]}),e(" ✅ "),l(c,{char:"井",parts:[3,1]}),e(" ❌ ")]),Do,o("div",Eo,[l(c,{char:"严",parts:[1,5,1]}),e(" ✅ "),l(c,{char:"严",parts:[3,2,2]}),e(" ❌ "),l(c,{char:"严",parts:[3,3,1]}),e(" ❌ ")]),Ro,o("div",go,[l(c,{char:"缓",parts:[3,4,3,2]}),e(" ✅ "),l(c,{char:"缓",parts:[3,4,2,3]}),e(" ❌ ")])]),Bo,o("div",Jo,[Oo,$o,o("div",zo,[l(c,{char:"夬",parts:[2,2]}),e(" ✅ "),l(c,{char:"夬",parts:[1,3]}),e(" ❌ ")]),Fo,o("div",Go,[l(c,{char:"丈",parts:[2,1]}),e(" ✅ "),l(c,{char:"丈",parts:[1,2]}),e(" ❌ ")])]),Ho,o("div",Ko,[Lo,o("ol",null,[Mo,o("li",null,[e("又一例："),Qo,e("。候选拆分"),Uo,e(),Wo,e(),Xo,e(),Yo,e("四种。 "),Zo,o("div",oe,[l(c,{char:"盡",parts:[4,1,4,5]}),e(" ✅ "),l(c,{char:"盡",parts:[3,2,4,5]}),e(" ❌ ")])]),o("li",null,[e("又一例："),ee,e(" yuē "),ce,e(" yóu。 "),le,o("div",se,[l(c,{char:"曱",parts:[4,1]}),e(" ✅ "),l(c,{char:"甴",parts:[2,1,2],colors:[1,2,1]}),e(" ✅ ")])])])]),te]))}});export{pe as __pageData,he as default};
