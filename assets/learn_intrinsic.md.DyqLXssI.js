import{_ as e}from"./chunks/Chaifen.vue_vue_type_script_setup_true_lang.Tg7FitTN.js";import{c as l,m as o,J as d,a as c,a4 as s,o as t}from"./chunks/framework.rq0FYgLR.js";const a=o("h1",{id:"字根的内在属性",tabindex:"-1"},[c("字根的内在属性 "),o("a",{class:"header-anchor",href:"#字根的内在属性","aria-label":'Permalink to "字根的内在属性"'},"​")],-1),i=o("p",null,[c("上面我们提到了宇浩拆分规则的优先级。其实，在「字根最少」之上，还有一个隐藏的原则，也就是："),o("strong",null,"字根的内在属性"),c("。")],-1),_=o("p",null,"何为字根的内在属性？其实就是指某一个字根区别于另一个字根的内在特点。",-1),r={class:"tip custom-block"},n=s('<p class="custom-block-title">例</p><p><code>吉</code>拆成<code>士口</code>而不是<code>土口</code>，<code>周</code>拆成<code>⺆土口</code>而不是<code>⺆士口</code>，这是因为<code>土</code>的下面一笔更长，而<code>士</code>的下面一笔更短。这是区别两个字根的本质原因和内在属性。</p>',2),h={class:"flex justify-left flex-wrap"},p=o("p",null,"「内在属性」可以解释为什么有些字这样拆而不是那样拆，有些字为什么看上去违反了「字根最少」的原则。",-1),u={class:"tip custom-block"},f=s('<p class="custom-block-title">例</p><p><code>敝</code>拆为<code>丷巾八攵</code>而非<code>氺巾攵</code>，这看似违反了「字根最少」原则，但其实没有。注意到，<code>敝</code>字左下的笔画是撇不是提；在<code>氺</code>中，左下角的笔画是提不是撇。故而，<code>敝</code>字里并不存在<code>氺</code>字根。正因为如此，我们取四根<code>丷巾八攵</code>而非三根<code>氺巾攵</code>。</p>',2),m={class:"flex justify-left flex-wrap"},x=s('<p>在这个章节，我们就详细讨论字根的内在属性，讨论某些字根在宇浩拆分中被分离或者被合并的原因，从而让某些字的拆分原因更加明确。</p><h2 id="日曰之辨" tabindex="-1">日曰之辨 <a class="header-anchor" href="#日曰之辨" aria-label="Permalink to &quot;日曰之辨&quot;">​</a></h2><p>不少输入法对与<code>日</code> <code>曰</code>两字的区分，比较复杂。大概有两种情况：</p><ul><li>有些是基于形状的，凡是长大于高的都为<code>曰</code>，凡是长短于高的都为<code>日</code>。但这个方法会跟随着字体的不同而不同，有时候不合字源，也不统一。例如：<code>書</code>字源于<code>聿者</code>，<code>曹</code>古字为<code>东东口</code>。</li><li>另外一种区分方法是基于字源。也就是说：凡是在古文中作<code>口</code>形，之后隶变为<code>曰</code>形或<code>甘</code>形的字，都作<code>曰</code>。但这个方法对方一般的使用者难度太大，且分析字源会有疏漏之处，不应用于输入法。</li></ul><p>我们必须注意到，在汉字中，存在<code>日曰</code>对立的字形，只有三组，分别为：<code>日曰</code>、<code>汨汩</code>、<code>曶㫚</code>。在其他的情况下，不存在对立，也就不存在混淆问题。</p><p>因此，我基于<strong>实用主义</strong>原则，对这两个字根不多加以区分，而采取更简单的方法。即：除了上述三组对立情况外，全部取<code>日</code>根。换句话说，<code>曰</code>根只需要在对立情况下才会使用，即：<code>曰</code> <code>汩</code> <code>㫚</code>三个字。</p><p>这样一来，可以显著降低使用者的记忆和学习负担。</p><h2 id="勹之辨" tabindex="-1">勹之辨 <a class="header-anchor" href="#勹之辨" aria-label="Permalink to &quot;勹之辨&quot;">​</a></h2><p><code>旬</code>的外框<code>勹</code>，同<code>敖</code>左下的<code>勹</code>都是撇加横折钩。宇浩输入法不做区分。</p><h2 id="点之辨" tabindex="-1">点之辨 <a class="header-anchor" href="#点之辨" aria-label="Permalink to &quot;点之辨&quot;">​</a></h2><p>这里对含点字根的识别和归并作出解释。</p><div class="info custom-block"><p class="custom-block-title">含点字根</p><ul><li>单点<code>丶</code>和捺<code>乀</code>视为同一个字根。</li><li>相重叠的两点，即<code>头</code> <code>冬</code>中的部分，和<code>二</code>同码位。</li><li>左对点<code>冫</code>和右对点<code>飞右</code>，和<code>二</code>同码位。</li><li>下对点<code>八</code>为一个字根。</li><li>上对点<code>丷</code> <code>䒑</code> <code>リ</code>同大码。</li><li>左<code>⺦</code>为一个字根。</li><li>左三点<code>氵</code>都在一个大码。</li><li>上三点<code>ッ𠁼</code>都在一个大码。</li><li>所有四点<code>灬</code>都在一个大码。</li></ul></div><p><code>为</code> <code>卵</code>等字的两点和<code>冬</code>下的两点不同，非连续笔画，且被半包围或全包围分割，故而不认定为「两点」。详<a href="#散件不分割">「散件不分隔」禁手</a>。</p>',13),b={class:"flex justify-left flex-wrap"},T=o("h2",{id:"人八入之辨",tabindex:"-1"},[c("人八入之辨 "),o("a",{class:"header-anchor",href:"#人八入之辨","aria-label":'Permalink to "人八入之辨"'},"​")],-1),k=o("p",null,[o("code",null,"人"),c(),o("code",null,"八"),c(),o("code",null,"入"),c("三字易混，这里做出区分。")],-1),v={class:"info custom-block"},P=o("p",{class:"custom-block-title"},"左撇右捺",-1),S=o("p",null,[c("凡左撇不低于右捺，视作"),o("code",null,"人"),c("根。")],-1),w={class:"flex justify-left flex-wrap"},A=o("p",null,[c("凡左撇低于右捺，视作"),o("code",null,"入"),c("根。")],-1),V={class:"flex justify-left flex-wrap"},j=o("p",null,[c("凡左撇右捺分离，视作"),o("code",null,"八"),c("根。")],-1),y={class:"flex justify-left flex-wrap"},N=o("p",null,[c("凡左撇右捺的中间被其他笔画隔开，视作"),o("code",null,"<丿乀>"),c("根。宇码中，它和"),o("code",null,"八"),c("同大小码。")],-1),q={class:"flex justify-left flex-wrap"},C=s('<h2 id="口中无整画" tabindex="-1">口中无整画 <a class="header-anchor" href="#口中无整画" aria-label="Permalink to &quot;口中无整画&quot;">​</a></h2><p>口（音<code>kǒu</code>），囗（音<code>wéi</code>）。这两个根如何区分？</p><p>答案是，如果方框里有<strong>完整</strong>的笔画，用<code>囗</code> <code>wéi</code>。否则一律用<code>口</code> <code>kǒu</code>。</p><div class="tip custom-block"><p class="custom-block-title">例</p><p><code>国</code>字中，有完整的笔画，故而必须用<code>囗</code> <code>wéi</code>。 <code>中</code>字中，虽然<code>⼁</code>穿<code>口</code>而过，但并未被完全包含在<code>口</code>中。由于<code>口</code>中没有完整的笔画，故而用<code>口</code> <code>kǒu</code>。</p></div><p>此规定也适用于另外几个包含<code>口</code>的字根。</p>',5),I={class:"tip custom-block"},g=o("p",{class:"custom-block-title"},"例",-1),D=o("code",null,"古",-1),E=o("code",null,"口",-1),R=o("code",null,"十囗",-1),B=o("code",null,"鄙",-1),J=o("code",null,"口",-1),O=o("code",null,"口",-1),$=o("code",null,"口十囗口阝",-1),z={class:"flex justify-left flex-wrap"},F=o("code",null,"合",-1),G=o("code",null,"口",-1),H=o("code",null,"人一囗",-1),K=o("code",null,"會",-1),L=o("code",null,"口",-1),M=o("code",null,"小",-1),Q=o("span",{class:"yuniversus"},"人一日",-1),U={class:"flex justify-left flex-wrap"},W=o("h2",{id:"弱根不分写",tabindex:"-1"},[c("弱根不分写 "),o("a",{class:"header-anchor",href:"#弱根不分写","aria-label":'Permalink to "弱根不分写"'},"​")],-1),X=o("p",null,"部分字根，姑且称之弱根，不能分成两次书写，必须一次书写完成。主要是为了防止不直观。比如「夔」字中的「一自八」不作「页」字根拆，因为它被「止㔾」穿插。这部分字根比较少，主要是一些出现散件的字根。这同「散件不分割」禁手类似。",-1),lo=JSON.parse('{"title":"字根的内在属性","description":"","frontmatter":{},"headers":[],"relativePath":"learn/intrinsic.md","filePath":"learn/intrinsic.md"}'),Y={name:"learn/intrinsic.md"},to=Object.assign(Y,{setup(Z){return(oo,co)=>(t(),l("div",null,[a,i,_,o("div",r,[n,o("div",h,[d(e,{char:"吉",parts:[3,3]}),d(e,{char:"周",parts:[2,3,3]})])]),p,o("div",u,[f,o("div",m,[d(e,{char:"敝",parts:[2,3,2,4]}),c(" ✅ "),d(e,{char:"敝",parts:[2,2,3,4],colors:[1,2,1,3]}),c(" ❌ ")])]),x,o("div",b,[d(e,{char:"冬",parts:[3,2],colors:[0,1]}),c(" ✅ "),d(e,{char:"为",parts:[1,2,1],colors:[1,0,1]}),c(" ❌ "),d(e,{char:"卵",parts:[2,1,1,2,1],colors:[0,1,0,0,1]}),c(" ❌ ")]),T,k,o("div",v,[P,o("ol",null,[o("li",null,[S,o("div",w,[d(e,{char:"令",parts:[2,1,3],colors:[1,0,0]}),d(e,{char:"内",parts:[2,2],colors:[0,1]}),d(e,{char:"两",parts:[1,2,2,2],colors:[0,0,1,2]})])]),o("li",null,[A,o("div",V,[d(e,{char:"籴",parts:[2,6],colors:[1,0]}),d(e,{char:"陝",parts:[2,1,2,2,2],colors:[0,0,0,1,2]}),d(e,{char:"兩",parts:[1,3,2,2],colors:[0,0,1,2]})])]),o("li",null,[j,o("div",y,[d(e,{char:"分",parts:[2,2],colors:[1,0]}),d(e,{char:"兴",parts:[4,2],colors:[0,1]}),d(e,{char:"典",parts:[6,2],colors:[0,1]})])]),o("li",null,[N,o("div",q,[d(e,{char:"办",parts:[2,2],colors:[0,1]}),d(e,{char:"朱",parts:[4,2],colors:[0,1]}),d(e,{char:"兼",parts:[8,2],colors:[0,1]})])])])]),C,o("div",I,[g,o("ul",null,[o("li",null,[D,c("下的"),E,c("中如果包含完整的笔画，应该拆如"),R,c("。例如："),B,c("左下方的"),J,c("中有"),O,c("，故而应该拆成"),$,c("。 "),o("div",z,[d(e,{char:"鄙",parts:[3,2,2,3,1,2],colors:[1,2,3,4,3,5]}),c(" ✅ "),d(e,{char:"鄙",parts:[3,4,3,1,2],colors:[1,2,3,2,4]}),c(" ❌ ")])]),o("li",null,[F,c("下的"),G,c("中如果包含完整的笔画，应该拆如"),H,c("。例如："),K,c("中间的"),L,c("中有"),M,c("，故而应该拆成"),Q,c("。 "),o("div",U,[d(e,{char:"會",parts:[2,1,6,4],colors:[1,2,3,4]}),c(" ✅ "),d(e,{char:"會",parts:[5,3,1,4],colors:[1,2,1,3]}),c(" ❌ ")])])])]),W,X]))}});export{lo as __pageData,to as default};
