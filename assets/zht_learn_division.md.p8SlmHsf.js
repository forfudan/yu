import{_ as c}from"./chunks/Chaifen.vue_vue_type_script_setup_true_lang.Tg7FitTN.js";import{c as t,m as o,J as l,a as e,a4 as s,o as d}from"./chunks/framework.rq0FYgLR.js";const a=s('<h1 id="單字拆分" tabindex="-1">單字拆分 <a class="header-anchor" href="#單字拆分" aria-label="Permalink to &quot;單字拆分&quot;">​</a></h1><div class="warning custom-block"><p class="custom-block-title">共用拆分</p><p>宇浩系列的所有輸入法，都使用相同的單字拆分規則。因此，本拆分教程對星陳輸入法、光華輸入法、卿雲輸入法、日月輸入法、吉旦餅輸入法全部適用。</p></div><h2 id="漢字拼圖" tabindex="-1">漢字拼圖 <a class="header-anchor" href="#漢字拼圖" aria-label="Permalink to &quot;漢字拼圖&quot;">​</a></h2><p>先前説過，拆字，就是把漢字按照一定的規則，拆成唯一的字根組合。這個過程如同拼圖一般，大多數時候，是非常直觀而自然的。</p>',4),_={class:"tip custom-block"},i=o("p",{class:"custom-block-title"},"例",-1),n={class:"flex justify-left flex-wrap"},r=o("p",null,"這種將字拆成直觀的、分離的部件的方法，足以應付大部分漢字的拆分了。但在實際使用中，遇到這個問題：一個獨體字，本身不是字根，怎麽辦？這時候，我們要把它繼續拆成更小的字根甚至筆劃。",-1),p={class:"tip custom-block"},h=s('<p class="custom-block-title">例</p><p><code>戋</code>這個字，我們可以繼續將它拆成<code>一</code>和<code>戈</code>。查字根圖可知，<code>一</code>和<code>戈</code>正好是兩個字根，拆字成功。</p><p><code>丸</code>這個字，我們可以繼續將它拆成<code>九</code>和<code>丶</code>。查字根圖可知，<code>九</code>和<code>丶</code>正好是兩個字根，拆字成功。</p><p><code>朱</code>這個字，我們可以繼續將它拆成<code>牛</code>和<code>八</code>。查字根圖可知，<code>牛</code>和<code>八</code>正好是兩個字根，拆字成功。</p>',4),u={class:"flex justify-left flex-wrap"},f=o("p",null,[e("有時候，獨體字的拆分不是很直觀。比如"),o("code",null,"再"),e("可以拆成"),o("code",null,"一冂土"),e("，也可以拆成"),o("code",null,"王冂"),e("。遇到此類字時的拆分，往往需要一些經驗和練習。所以當你遇到不會拆的字時，應該主動查詢它的編碼，及時學習。")],-1),T=o("p",null,[e("更麻煩的情況是，"),o("strong",null,"一個字好像有幾種拆分方法"),e("。")],-1),m={class:"tip custom-block"},x=o("p",{class:"custom-block-title"},"例",-1),b=o("p",null,[o("code",null,"井"),e("，可以拆"),o("code",null,"二{介下}"),e("，也可以拆"),o("code",null,"一廾"),e("。")],-1),k={class:"flex justify-left flex-wrap"},v=o("p",null,[o("code",null,"单"),e("可以拆成"),o("code",null,"丷日十"),e("也可以拆成"),o("code",null,"丷冂丰"),e("。")],-1),P={class:"flex justify-left flex-wrap"},S=o("p",null,[o("code",null,"主"),e("可以拆成"),o("code",null,"丶王"),e("也可以拆成"),o("code",null,"亠土"),e("。")],-1),A={class:"flex justify-left flex-wrap"},V=s('<p>這種一字多拆的情況，任何形碼中，都是希望避免的。因爲一字多拆，會造成極大的不確定性，並造成編碼的混亂<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>宇浩輸入法總結了拆字規則，並且不斷自我審視每一個拆分是否符合規則。通過大量的努力，明確了一套優先級系統。使每一個漢字，都有唯一的拆分方案，消除了不確定性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><div class="info custom-block"><p class="custom-block-title">拆字優先級</p><p>「宇浩」拆字規則，按優先級排序如下：</p><ol><li>字根最少</li><li>結構完整</li><li>符合筆順</li><li>散連交斷</li><li>字根取大</li></ol><p>以上優先級，還可以高度歸納爲：<strong>少整順散連交斷大</strong>。</p></div><p>取根時，如果有多種不同的拆分方式，則按<strong>優先級從高到低</strong>依次檢查以上規則，選取符合條件的，排除不滿足的，最終得到唯一的拆分方案。因此，某種意義上來説，宇浩輸入法的拆分規則，其實是一種「比較和淘汰」的排除法，後文中會展示這些步驟的機器實現。</p><p>以下爲拆分規則詳細介紹<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p><h2 id="字根最少" tabindex="-1">字根最少 <a class="header-anchor" href="#字根最少" aria-label="Permalink to &quot;字根最少&quot;">​</a></h2><p>字根最少，意思是拆分一個字時，應該使得字根的數量最少。保證字根數量最少，是第一優先級最高的規則。</p>',7),y={class:"tip custom-block"},j=o("p",{class:"custom-block-title"},"例",-1),w=o("p",null,[o("code",null,"国"),e("如果完全符合筆順，應該拆成"),o("code",null,"冂王丶一"),e("，是四個字根。但拆成"),o("code",null,"囗王丶"),e("，只用三個字根就夠了。因爲「少」優先級高於「順」，所以應該拆成"),o("code",null,"囗王丶"),e("。")],-1),C={class:"flex justify-left flex-wrap"},I=o("p",null,[o("code",null,"國"),e("如果完全符合筆順，應該拆成"),o("code",null,"冂一口一丿丶一"),e("，是七個字根。但拆成"),o("code",null,"囗戈口一"),e("，只用四個字根就夠了。因爲「少」優先級高於「順」，所以應該拆成"),o("code",null,"囗戈口一"),e("。")],-1),q={class:"flex justify-left flex-wrap"},N=o("h2",{id:"結構完整",tabindex:"-1"},[e("結構完整 "),o("a",{class:"header-anchor",href:"#結構完整","aria-label":'Permalink to "結構完整"'},"​")],-1),D=o("p",null,[e("結構完整，指的是"),o("code",null,"囗日目勹冂匚コ凵"),e("等存在全包圍和半包圍結構的字根不拆散。")],-1),E=o("p",null,"這個原則的設置，是爲了不過分破壞漢字的整體性和直觀性。",-1),R={class:"tip custom-block"},g=o("p",{class:"custom-block-title"},"例",-1),z=o("p",null,[o("code",null,"昜"),e("拆"),o("code",null,"日一勹彡"),e("不拆"),o("code",null,"日丆𠃌彡"),e("。")],-1),B={class:"flex justify-left flex-wrap"},J=o("p",null,[o("code",null,"单"),e("可以拆成"),o("code",null,"丷日十"),e("也可以拆成"),o("code",null,"丷冂丰"),e("。兩者都是三根。因爲包圍結構不拆散，故而"),o("code",null,"单"),e("拆成"),o("code",null,"丷日十"),e("。")],-1),O={class:"flex justify-left flex-wrap"},$=o("p",null,[o("code",null,"免"),e("可以拆成"),o("code",null,"⺈口儿"),e("也可以拆成"),o("code",null,"⺈冂尢"),e("。兩者都是三根。因爲包圍結構不拆散，故而"),o("code",null,"免"),e("拆成"),o("code",null,"⺈口儿"),e("。")],-1),F={class:"flex justify-left flex-wrap"},G=o("p",null,[o("code",null,"万"),e("拆成"),o("code",null,"一勹"),e("而非"),o("code",null,"{一丿}乛"),e("。因爲前者不僅完全符合筆順，同時也保持了結構完整。")],-1),H={class:"flex justify-left flex-wrap"},K=o("p",null,[o("code",null,"匹"),e("拆"),o("code",null,"匚儿"),e("而不拆"),o("code",null,"兀乚"),e("，因爲前者結構完整。")],-1),L={class:"flex justify-left flex-wrap"},M=s('<h2 id="符合筆順" tabindex="-1">符合筆順 <a class="header-anchor" href="#符合筆順" aria-label="Permalink to &quot;符合筆順&quot;">​</a></h2><p>注意到，爲了使字根數量較少，某些大於等於兩劃的字根，它的筆順可能會被另一個或多個字根穿插打斷。比如<code>固</code>字拆<code>囗古</code>時，<code>囗</code>不是一次性寫完，而是分成俩次寫完的。</p><p>符合筆順，指的是字根之間不穿插寫成<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。它有兩種情況：</p><ul><li>整體符合筆順：指一個字完全按照筆順寫成，字根間不會互相干擾筆順。<code>固</code>字如拆<code>冂古一</code>，便算作整體符合筆順。</li><li>局部符合筆順：指一個字雖不能完全按照筆順寫成，但局部字根符合筆順。<code>固</code>字如拆<code>囗古</code>，便算作局部符合筆順，且符合筆順的有一個字根「古」，共五畫。</li></ul><p>「符合筆順」規則，指一個字是否整體符合筆順（後面的「取大」規則中，會繼續判断局部符合筆順的字根數量）。</p><p>符合筆順的優先級低於字根最少。</p>',6),Q={class:"tip custom-block"},U=o("p",{class:"custom-block-title"},"例",-1),W=o("p",null,[o("code",null,"来"),e("可以拆成"),o("code",null,"一米"),e("也可以拆成"),o("code",null,"未丷"),e("，都是兩根，但拆成"),o("code",null,"一米"),e("完全符合筆順。")],-1),X={class:"flex justify-left flex-wrap"},Y=o("p",null,[o("code",null,"聿"),e("可以拆成"),o("code",null,"彐キ"),e("也可以拆成"),o("code",null,"肀二"),e("，都是兩根，但拆成"),o("code",null,"彐キ"),e("完全符合筆順。")],-1),Z={class:"flex justify-left flex-wrap"},oo=s('<h2 id="散連交斷" tabindex="-1">散連交斷 <a class="header-anchor" href="#散連交斷" aria-label="Permalink to &quot;散連交斷&quot;">​</a></h2><p><strong>散·連·交·斷</strong>，是漢字部首或筆畫的四種狀態。</p><ul><li>字根離散，指的是兩個字根互相分離。比如<code>部</code>中的<code>立口阝</code>，便是三個分離的字根。</li><li>字根相連，指的是兩個字根互相連接。比如<code>美</code>拆爲<code>𦍌大</code>，這兩個字根是相連的。</li><li>字根相交，指的是兩個字根互相交叉。比如<code>再</code>拆成<code>一冂土</code>三個字根，便是相交的。</li><li>筆劃斷開，指的是一個筆劃（橫或豎）斷開。比如<code>我</code>拆成<code>丿扌戈</code>三個字根，其中的<code>扌</code>和<code>戈</code>兩根的橫本是一筆寫成，但我們將橫畫斷開。</li></ul><p>「散連交斷」，優先級依次下降，但都排在「字根最少」「結構完整」「符合筆順」之後。</p><h3 id="能散不連" tabindex="-1">能散不連 <a class="header-anchor" href="#能散不連" aria-label="Permalink to &quot;能散不連&quot;">​</a></h3><p>兩個字根互相分離，優於兩個字根互相連接。</p>',6),eo={class:"tip custom-block"},co=o("p",{class:"custom-block-title"},"例",-1),lo=o("p",null,[o("code",null,"主"),e("可以拆成"),o("code",null,"丶王"),e("也可以拆成"),o("code",null,"亠土"),e("。觀察到，"),o("code",null,"丶王"),e("是散開的，而"),o("code",null,"亠土"),e("是相連的，後者符合「能散不連」。")],-1),so={class:"flex justify-left flex-wrap"},to=o("h3",{id:"能連不交",tabindex:"-1"},[e("能連不交 "),o("a",{class:"header-anchor",href:"#能連不交","aria-label":'Permalink to "能連不交"'},"​")],-1),ao=o("p",null,"兩個字根互相分離，優於兩個字根互相交叉。",-1),_o={class:"tip custom-block"},io=o("p",{class:"custom-block-title"},"例",-1),no=o("p",null,[o("code",null,"开"),e("可以拆成"),o("code",null,"一廾"),e("也可以拆成"),o("code",null,"二{介下}"),e("。觀察到，第一種拆法字根相連，第二種拆法字根相交。故而拆成"),o("code",null,"一廾"),e("符合「能連不交」。")],-1),ro={class:"flex justify-left flex-wrap"},po=o("h3",{id:"能交不斷",tabindex:"-1"},[e("能交不斷 "),o("a",{class:"header-anchor",href:"#能交不斷","aria-label":'Permalink to "能交不斷"'},"​")],-1),ho=o("p",null,"兩個字根互相交叉，優於將筆畫斷開。",-1),uo={class:"tip custom-block"},fo=s('<p class="custom-block-title">例</p><p><code>果</code>拆作<code>日木</code>，不拆成<code>田木</code>或<code>甲木</code>，這是因爲後者將中間的豎斷開了。因爲「字根相交」的優先級高於「筆畫斷開」，<code>果</code>應當拆成<code>日木</code>。</p>',2),To={class:"flex justify-left flex-wrap"},mo=s('<h3 id="根少而斷" tabindex="-1">根少而斷 <a class="header-anchor" href="#根少而斷" aria-label="Permalink to &quot;根少而斷&quot;">​</a></h3><p>爲了根少和直觀，有且只有以下兩種情況可以斷開筆畫：</p><ol><li><code>我識羲</code>等字中<code>戈</code>的橫。</li><li><code>重熏</code>等字中<code>千</code>的竪。</li></ol>',3),xo={class:"tip custom-block"},bo=o("p",{class:"custom-block-title"},"例",-1),ko=o("p",null,[o("code",null,"我"),e("拆作"),o("code",null,"丿扌戈"),e("，不拆成"),o("code",null,"丿扌乚丿丶"),e("。雖然前者將中間的橫斷開了，但因爲「字根最少」，我們選擇只有三根的"),o("code",null,"丿扌戈"),e("。")],-1),vo={class:"flex justify-left flex-wrap"},Po=o("p",null,[o("code",null,"熏"),e("拆作"),o("code",null,"千黑"),e("，不拆成"),o("code",null,"千囗丷二灬"),e("。雖然前者將中間的豎斷開了，但因爲「字根最少」，我們選擇只有兩根的"),o("code",null,"千黑"),e("。")],-1),So={class:"flex justify-left flex-wrap"},Ao=s('<h2 id="字根取大" tabindex="-1">字根取大 <a class="header-anchor" href="#字根取大" aria-label="Permalink to &quot;字根取大&quot;">​</a></h2><p>字根取大，指的是按照筆順拆字時：</p><ul><li>讓非「豎·撇變形部分」儘可能地大。</li><li>讓首筆靠前的字根儘可能地大。</li></ul><h3 id="非變形部分取大" tabindex="-1">非變形部分取大 <a class="header-anchor" href="#非變形部分取大" aria-label="Permalink to &quot;非變形部分取大&quot;">​</a></h3><p>部分字根在做偏旁的時候，由於書法的考慮，會有「豎變撇」「撇變豎」的變化。它們稱爲「豎·撇變形根」。</p><div class="info custom-block"><p class="custom-block-title">豎·撇變形根</p><p><code>千</code>字根的<code>丨</code>變成<code>丿</code></p><p><code>干</code>字根的<code>丨</code>變成<code>丿</code></p><p><code>キ</code>字根的<code>丨</code>變成<code>丿</code></p><p><code>丰</code>字根的<code>丨</code>變成<code>丿</code></p><p><code>羊</code>字根的<code>丨</code>變成<code>丿</code></p><p><code>丌</code>字根的<code>丿</code>變成<code>丨</code></p></div><p>我們應當對非變形部分取大。</p>',7),Vo={class:"tip custom-block"},yo=o("p",{class:"custom-block-title"},"例",-1),jo=o("p",null,[o("code",null,"失"),e("拆"),o("code",null,"丿夫"),e("而不拆"),o("code",null,"牛乀"),e("，因爲"),o("code",null,"牛"),e("的一豎是撇。故而對"),o("code",null,"夫"),e("取大。")],-1),wo={class:"flex justify-left flex-wrap"},Co=o("p",null,[o("code",null,"井"),e("拆"),o("code",null,"二{介下}"),e("而不拆"),o("code",null,"キ丨"),e("，因爲"),o("code",null,"キ"),e("的一豎是撇。故而對"),o("code",null,"{介下}"),e("取大。")],-1),Io={class:"flex justify-left flex-wrap"},qo=s('<p><code>严</code>拆爲<code>一业丿</code>，而不拆成<code>丌丷厂</code>，因爲後者中，<code>丌</code>字根的<code>丿</code>變成<code>丨</code>。爲了讓非「豎·撇變形根」儘可能地大，我們取<code>业</code>根。</p><p>另外一種拆法<code>丌䒑丿</code>不取的原因是<code>䒑</code>字根中的點應當和橫相連（艹字頭的行書寫法），而<code>严</code>字中兩點分散了。這違反了<a href="./intrinsic.html">字根的內在屬性</a>。</p>',2),No={class:"flex justify-left flex-wrap"},Do=o("p",null,[o("code",null,"缓"),e("拆"),o("code",null,"纟爪干又"),e("而不拆"),o("code",null,"纟爪二夂"),e("。雖然前者"),o("code",null,"干"),e("的豎是撇，但後者出現了「字根相交」。根據規則優先級，「字根相交」低於「字根相連」，故而拆爲"),o("code",null,"纟爪干又"),e("。")],-1),Eo={class:"flex justify-left flex-wrap"},Ro=s('<h3 id="不對稱部分取大" tabindex="-1">不對稱部分取大 <a class="header-anchor" href="#不對稱部分取大" aria-label="Permalink to &quot;不對稱部分取大&quot;">​</a></h3><p>部分字根在做獨體字時，會有不對稱的情況。我們應對不對稱部分取大。</p><p>此規則只出現於大字集中。</p><div class="tip custom-block"><p class="custom-block-title">例</p><p><code>宺</code>拆<code>宀口一𫶧</code>而不拆<code>宀口丌乚</code>，因爲拆爲<code>丌乚</code>破壞了字根<code>丌</code>的對稱性。</p></div><h3 id="向前取大" tabindex="-1">向前取大 <a class="header-anchor" href="#向前取大" aria-label="Permalink to &quot;向前取大&quot;">​</a></h3><p>向前取大，讓首筆靠前的字根的筆劃數儘量地多。這是一個兜底原則，可以保證最終只有一個候選方案能夠勝出。因此，它的優先級必然是所有拆字規則中最低的。</p>',6),go={class:"tip custom-block"},zo=o("p",{class:"custom-block-title"},"例",-1),Bo=o("p",null,[o("code",null,"夬"),e("拆爲"),o("code",null,"ユ人"),e("，而不拆成"),o("code",null,"乛大"),e("，因爲「字根取大」原則。讓首筆靠前的字根的筆劃數儘量地多，這裡，"),o("code",null,"ユ"),e("的筆畫數大於"),o("code",null,"乛"),e("。")],-1),Jo={class:"flex justify-left flex-wrap"},Oo=o("p",null,[o("code",null,"丈"),e("拆爲"),o("code",null,"𠂇丶"),e("，而不拆成"),o("code",null,"一乂"),e("，因爲「字根取大」原則。讓首筆靠前的字根的筆劃數儘量地多，這裡，"),o("code",null,"𠂇"),e("的筆畫數大於"),o("code",null,"一"),e("。")],-1),$o={class:"flex justify-left flex-wrap"},Fo=s('<h2 id="拆字舉例" tabindex="-1">拆字舉例 <a class="header-anchor" href="#拆字舉例" aria-label="Permalink to &quot;拆字舉例&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">更多例字</p><p>想要了解更多具有代表性的例字在宇碼中的拆分，請參見<a href="./examples.html">字海拾珍——必拆字舉隅</a>。</p><p>如果你想了解使用頻率最爲靠前的幾百個漢字在宇碼中的拆分，可以點擊進入<a href="./frequent.html">高頻字拆分圖解（簡化字）</a>或<a href="./frequent_tc.html">高頻字拆分圖解（傳統字）</a>頁面。</p></div><p>實際拆字時，如果你感覺拆分方法不唯一，那麽可以用以下方法找到最優解：</p><ul><li>列出所有可能的候選拆分方案。</li><li>依照「少整順散連交斷大」的規則順序，依次比較各個候選拆分。</li><li>如果所有的候選拆分都不滿足本條規則，則進入下條規則。</li><li>如果部分的候選拆分滿足本條規則，則該部分的候選拆分方案進入下條規則。</li><li>直到只有一個候選拆分方案勝出。</li></ul><p>以下通過部分例字來説明拆分規則：</p>',5),Go={class:"tip custom-block"},Ho=o("p",{class:"custom-block-title"},"例",-1),Ko=s("<li>一例：<code>亷</code>。候選拆分<code>亠丷厂彐〢八</code>和<code>立丿彐〢八</code>。 <ul><li><code>亠丷厂彐〢八</code>六根，<code>立丿彐〢八</code>五根。後者字根最少，直接勝出。</li></ul></li><li>又一例：<code>重</code>。候選拆分<code>丿車一</code>和<code>千里</code>。 <ul><li><code>千里</code>是兩根，滿足「字根最少」，直接雖然中間一豎斷開，但依然勝出。</li></ul></li>",2),Lo=o("code",null,"盡",-1),Mo=o("code",null,"コ土灬皿",-1),Qo=o("code",null,"乛龶灬皿",-1),Uo=o("code",null,"彐丄灬皿",-1),Wo=o("code",null,"{聿上}一灬皿",-1),Xo=o("ul",null,[o("li",null,"都是四根，同時滿足「字根最少」。"),o("li",null,[o("code",null,"コ土灬皿"),e("不符合筆順，其他三者都完全符合筆順。淘汰"),o("code",null,"コ土灬皿"),e("。")]),o("li",null,"上半部分都出現字根相交情況。"),o("li",null,"都不適用「結構合理」。"),o("li",null,[e("進入兜底規則「字根取大」。根據規則，只要其中某個字根多寫一筆仍然符合筆順，就多寫一筆。觀察到，"),o("code",null,"{聿上}一灬皿"),e("的第一根一共寫了四筆，故而勝出。")])],-1),Yo={class:"flex justify-left flex-wrap"},Zo=o("code",null,"曱",-1),oe=o("code",null,"甴",-1),ee=s("<ul><li><code>曱</code>按笔顺取大，故而是<code>日丨</code>。</li><li><code>甴</code>，候选拆分为<code>日丨</code> <code>囗丄</code>。两者都是两根，都結構完整。按笔顺取大，故而是<code>日丨</code>。</li></ul>",1),ce={class:"flex justify-left flex-wrap"},le=s('<p>上面的例子邏輯雖比較複雜，但是最終的結果還是非常直觀的。在宇浩輸入法中，大多數的時候，直觀的拆分方法往往也是符合規則的。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>前輩輸入法的拆字規則，一般都有諸如「直觀」、「符合筆順」、「取大」等設置。但是優先級往往不夠明確，很多拆分方法並不符合規則，存在不少特例。在常用字範圍內，還可以通過大量練習來完成記憶，但到了大字集，規則不明確、規則相矛盾，都是造成檢字困難的因素。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>當然，漢字不是完全可以量化的，不同字形下，也會出現不同的拆分可能。除了良好的定義外，有時候比例原則也很重要。尤其在大字集上，追求單一拆分方法會扭曲漢字直觀性，不能兼顧不同字形，讓使用者需要大量嘗試才能找到想要的字，這違背了大字集檢字的初衷。因此，對於大字集，也會設置兼容拆分和容錯碼。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>在進行拆分前，首先需要「確認」某個字根到底存不存在，是否合規，也就是檢查字根的「內在屬性」。比如<code>土</code> <code>士</code>，兩橫的長度直接決定了字根的異同。其次需要檢查一些「拆分禁手」，比如<code>王</code>中間如果被筆畫「穿心」，這是不被允許的。禁手有：散件不分割、豎向不包夾、橫間不穿心。對這兩點的討論作爲進階內容，於此處跳過。若有興趣，可以在後續章節 《進階討論》中閱讀。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>爲什麽要有完全合筆順這個規則，而且優先級那麽高？在我的認知中，形碼的基本出發點就是如同寫字一樣輸入一系列筆畫，即「五筆畫輸入法」。它是最自然，最直觀的，所以宇碼規則有了「符合筆順」。但是，輸入講求效率，必須把一些筆畫合併起來形成字根，它們的筆順可能會相互穿插，所以要有「根少優先」這個規則，把它的優先級放在了「符合筆順」的前面。最後，需要有個兜底條款「向前取大」來保證沒有拆分歧義。因此，形碼拆分有了「根少」「筆順」「取大」，其實已經足夠了。接下來的其他規則都是在這上面打補丁，爲了讓拆分更加「直觀」。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>',3),ne=JSON.parse('{"title":"單字拆分","description":"","frontmatter":{},"headers":[],"relativePath":"zht/learn/division.md","filePath":"zht/learn/division.md"}'),se={name:"zht/learn/division.md"},re=Object.assign(se,{setup(te){return(de,ae)=>(d(),t("div",null,[a,o("div",_,[i,o("div",n,[l(c,{char:"糧",parts:[6,4,1,7]}),l(c,{char:"錘",parts:[8,3,4,1]}),l(c,{char:"錢",parts:[8,4,4]}),l(c,{char:"瓶",parts:[3,3,4]}),l(c,{char:"琴",parts:[4,4,2,1,1]}),l(c,{char:"鴿",parts:[6,11]})])]),r,o("div",p,[h,o("div",u,[l(c,{char:"戋",parts:[1,4]}),l(c,{char:"丸",parts:[2,1]}),l(c,{char:"朱",parts:[4,2]})])]),f,T,o("div",m,[x,b,o("div",k,[l(c,{char:"井",parts:[1,3]}),e(" ❓ "),l(c,{char:"井",parts:[2,2]}),e(" ❓ "),l(c,{char:"井",parts:[3,1]}),e(" ❓ ")]),v,o("div",P,[l(c,{char:"单",parts:[2,4,2]}),e(" ❓ "),l(c,{char:"单",parts:[2,2,1,1,2],colors:[1,2,3,2,3]}),e(" ❓ "),l(c,{char:"单",parts:[2,2,4]}),e(" ❓ ")]),S,o("div",A,[l(c,{char:"主",parts:[1,4]}),e(" ❓ "),l(c,{char:"主",parts:[2,3]}),e(" ❓ "),l(c,{char:"主",parts:[1,3,1],colors:[1,2,1]}),e(" ❓ ")])]),V,o("div",y,[j,w,o("div",C,[l(c,{char:"国",parts:[2,4,1,1],colors:[1,2,3,1]}),e(" ✅ "),l(c,{char:"国",parts:[2,4,1,1]}),e(" ❌ ")]),I,o("div",q,[l(c,{char:"國",parts:[2,1,3,1,3,1],colors:[1,2,3,4,2,1]}),e(" ✅ "),l(c,{char:"國",parts:[2,1,3,1,1,1,1,1]}),e(" ❌ ")])]),N,D,E,o("div",R,[g,z,o("div",B,[l(c,{char:"昜",parts:[4,1,2,2]}),e(" ✅ "),l(c,{char:"昜",parts:[4,2,1,2]}),e(" ❌ ")]),J,o("div",O,[l(c,{char:"单",parts:[2,4,2]}),e(" ✅ "),l(c,{char:"单",parts:[2,2,4]}),e(" ❌ ")]),$,o("div",F,[l(c,{char:"免",parts:[2,3,2]}),e(" ✅ "),l(c,{char:"免",parts:[2,2,3]}),e(" ❌ ")]),G,o("div",H,[l(c,{char:"万",parts:[1,2]}),e(" ✅ "),l(c,{char:"万",parts:[1,1,1],colors:[1,2,1]}),e(" ❌ ")]),K,o("div",L,[l(c,{char:"匹",parts:[1,2,1],colors:[1,2,1]}),e(" ✅ "),l(c,{char:"匹",parts:[3,1]}),e(" ❌ ")])]),M,o("div",Q,[U,W,o("div",X,[l(c,{char:"来",parts:[1,6]}),e(" ✅ "),l(c,{char:"来",parts:[1,2,4],colors:[1,2,1]}),e(" ❌ ")]),Y,o("div",Z,[l(c,{char:"聿",parts:[3,3]}),e(" ✅ "),l(c,{char:"聿",parts:[3,2,1],colors:[1,2,1]}),e(" ❌ ")])]),oo,o("div",eo,[co,lo,o("div",so,[l(c,{char:"主",parts:[1,4]}),e(" ✅ "),l(c,{char:"主",parts:[2,3]}),e(" ❌ ")])]),to,ao,o("div",_o,[io,no,o("div",ro,[l(c,{char:"开",parts:[1,3]}),e(" ✅ "),l(c,{char:"开",parts:[2,2]}),e(" ❌ ")])]),po,ho,o("div",uo,[fo,o("div",To,[l(c,{char:"果",parts:[4,4]}),e(" ✅ "),l(c,{char:"果",parts:[4,1,1,2],colors:[1,2,0,2]}),e(" ❌ ")])]),mo,o("div",xo,[bo,ko,o("div",vo,[l(c,{char:"我",parts:[1,1,2,3],colors:[1,0,2,3,5,1]}),e(" ✅ "),l(c,{char:"我",parts:[1,3,1,1,1]}),e(" ❌ ")]),Po,o("div",So,[l(c,{char:"熏",parts:[2,5,1,6],colors:[1,2,0,2,3,5,1]}),e(" ✅ "),l(c,{char:"熏",parts:[2,2,2,1,1,2,4],colors:[1,2,3,2,1,4,5]}),e(" ❌ ")])]),Ao,o("div",Vo,[yo,jo,o("div",wo,[l(c,{char:"失",parts:[1,4]}),e(" ✅ "),l(c,{char:"失",parts:[4,1],colors:[1,2]}),e(" ❌ ")]),Co,o("div",Io,[l(c,{char:"井",parts:[2,2]}),e(" ✅ "),l(c,{char:"井",parts:[3,1]}),e(" ❌ ")]),qo,o("div",No,[l(c,{char:"严",parts:[1,5,1]}),e(" ✅ "),l(c,{char:"严",parts:[3,2,2]}),e(" ❌ "),l(c,{char:"严",parts:[3,3,1]}),e(" ❌ ")]),Do,o("div",Eo,[l(c,{char:"缓",parts:[3,4,3,2]}),e(" ✅ "),l(c,{char:"缓",parts:[3,4,2,3]}),e(" ❌ ")])]),Ro,o("div",go,[zo,Bo,o("div",Jo,[l(c,{char:"夬",parts:[2,2]}),e(" ✅ "),l(c,{char:"夬",parts:[1,3]}),e(" ❌ ")]),Oo,o("div",$o,[l(c,{char:"丈",parts:[2,1]}),e(" ✅ "),l(c,{char:"丈",parts:[1,2]}),e(" ❌ ")])]),Fo,o("div",Go,[Ho,o("ol",null,[Ko,o("li",null,[e("又一例："),Lo,e("。候選拆分"),Mo,e(),Qo,e(),Uo,e(),Wo,e("四種。 "),Xo,o("div",Yo,[l(c,{char:"盡",parts:[4,1,4,5]}),e(" ✅ "),l(c,{char:"盡",parts:[3,2,4,5]}),e(" ❌ ")])]),o("li",null,[e("又一例："),Zo,e(" yuē "),oe,e(" yóu。 "),ee,o("div",ce,[l(c,{char:"曱",parts:[4,1]}),e(" ✅ "),l(c,{char:"甴",parts:[2,1,2],colors:[1,2,1]}),e(" ✅ ")])])])]),le]))}});export{ne as __pageData,re as default};
